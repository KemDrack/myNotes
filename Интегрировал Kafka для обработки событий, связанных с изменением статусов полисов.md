```
При создании, продлении или аннулировании полиса я отправлял соответствующее событие в Kafka. Это позволило асинхронно обрабатывать эти события в других сервисах, таких как сервис уведомлений или аналитики. Я использовал Golang для реализации продюсера и потребителя Kafka. Также я настроил структуру сообщений, чтобы они содержали всю необходимую информацию для обработки, например, ID полиса, ID пользователя и новый статус
```

Использовал **Kafka**, чтобы асинхронно обрабатывать события: 
✔ Покупка нового страхового полиса  
✔ Продление полиса  
✔ Аннулирование полиса

При изменении статуса полиса можно отправить уведомление пользователю или обновить данные в других системах

---
**Какие события ты отправлял в Kafka?**
- **Определение топиков (topics)**: Какие события будут отправляться в Kafka. Например:
    - `policy_created` — создание нового полиса
    - `policy_updated` — изменение данных полиса (например, продление)
    - `policy_cancelled` — аннулирование полиса
- **Определение потребителей (consumers)**: Какие сервисы будут обрабатывать события (например, сервис уведомлений или аналитики) который подписывался на `policy_events` и обрабатывал изменения статусов.
- Когда полис изменял статус (покупка, продление, отмена), ты отправлял событие в Kafka.**Producer**

**Продюсер отправлял события при изменениях**  
Консюмеры могли подписываться и обрабатывать их независимо

---
Ты создавал сообщения при изменении статуса полиса, например:
