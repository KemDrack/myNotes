

**RabbitMQ** — это брокер сообщений,который используется для обмена данными между приложениями, микросервисами

Следует протоколу **AMQP**

Соообщения в RabbitMQ не хранятся, а в Kafka могут храниться сколько мы им скажем
Используются разные модели передачи данных, у Kafka это модель pull, а у Rabbit push

В целом кафка ставится если большой объем данных нужно обрабатывать с высокой пропускной способностью, а ребит, если используется сложная маршрутизация через сервисы, много сервисов, с меньшей пропускной способностью

Из чего состоит RabbitMQ внутренне:
1. **Producer**: то что отправляет сообщения в RabbitMQ.
2. **Exchange**: Обменник принимает сообщения от Producer и маршрутизирует их в очереди
3. **Queue**: Очередь хранит сообщения до их обработки Consumer. Сообщения хранятся в порядке FIFO
4. **Consumer**: Получает и обрабатывает сообщения
5. **Binding**: Привязка определяет, как сообщения из обменника отправляются в очередь.


Типы обменников в RabbitMQ

| Тип         | Описание                                                                         | Пример использования                        |
| ----------- | -------------------------------------------------------------------------------- | ------------------------------------------- |
| **Direct**  | Сообщения отправляются в очередь, если ключ маршрутизации совпадает с привязкой. | Рассылка уведомлений по конкретным каналам. |
| **Fanout**  | Сообщения отправляются во все очереди, привязанные к обменнику.                  | Широковещательная рассылка.                 |
| **Topic**   | Сообщения отправляются в зависимости от шаблона ключа маршрутизации.             | Логирование событий по категориям.          |
| **Headers** | Сообщения маршрутизируются на основе заголовков, а не ключей маршрутизации.      | Рассылка на основе сложных условий.         |



- Producer отправляет сообщение в обменник, указывая ключ маршрутизации (routing key).
- Обменник использует правила маршрутизации (bindings) для определения, в какую очередь отправить сообщение
- Сообщение остается в очереди до тех пор, пока его не получит потребитель.
- Consumer подключается к очереди и получает сообщения для обработки.
