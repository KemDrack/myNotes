
- **Расшифровать ACID**
    
    Atomicity, Consistency, Isolation, Durability — основные свойства транзакций.
    
- **Что такое составной индекс (Compound Index)?**
    
    Индекс, созданный на основе нескольких колонок таблицы, для ускорения сложных запросов.
- **Что такое шардирование?**
    
    Шардирование — это горизонтальное разделение данных на несколько частей (шардов) для распределения нагрузки между серверами.
    
- **Что такое репликация?**
    
    Репликация — это процесс создания копий данных на нескольких серверах для повышения доступности и отказоустойчивости
    
- **Привести примеры агрегатных функций**
    
    - **`SUM()`**: Вычисляет сумму значений по колонке.
    - **`COUNT()`**: Считает количество строк в наборе данных.
    - **`AVG()`**: Вычисляет среднее значение по колонке.
    - **`MAX()`**: Находит максимальное значение в наборе.
    - **`MIN()`**: Находит минимальное значение в наборе.

### Виды JOIN'ов?
[[Виды JOIN]]

<font color="#9bbb59">Inner join</font> - возвращает строки, для которых есть хотя бы одно совпадение в обеих таблицах

<font color="#9bbb59">Left join</font> - возвращает строки из левой и соответсвующие строки из правой таблицы. Если совпадений нет - NULL  
  
<font color="#9bbb59">Right join</font> - возвращает строки из правой и соответсвующие строки из левой таблицы. Если совпадений нет - NULL  
  
<font color="#9bbb59">Full join</font> - Возвращает строки, для которых есть совпадение в любой из таблиц. Если нет совпадений, возвращаются NULL

### Уровни изоляций транзакций?

[[Изолированность]]

### Что такое транзакция?

Это операция над базой данных(Чтение, запись, модификация), которая должна быть выполнена полностью или отменена. Также она обладает свойствами [[ACID]]

### Основные свойства транзакции? **(ACID)**

[[ACID]]

### Что такое Реплицирование?

**Репликация (реплика) -** Процесс горизонтального масштабирования ([[масштабирование]]), при котором мы создаем копии (реплики) оригинальной базы данных, в результате которого улучшается:

- **Отказоустойчивость** (возможность восстановления в случае сбоя или потери данных в основной базе данных)  
- **Улучшение производительности (Распределение нагрузки)  
  
<u>Типы репликации:</u>
[[Master - Master]] (**Оба сервера обмениваются данными**)
Два (или больше) сервера одновременно принимают изменения данных и синхронизируют их между собой
  
[[Master - Slave]] (**Один сервер принимает данные, второй получает обновления**) Slave -> обрабатывает только запросы на чтение

Один сервер (Master) отвечает за записи, а остальные серверы (Slaves) только принимают копии данных от Master и обрабатывают запросы на чтение

#### Когда использовать?

**Master-Master:**
- Подходит для систем, где запись данных может происходить в нескольких точках (например, распределённые системы)
- Необходима высокая отказоустойчивость
**Master-Slave:**
- Идеально для систем, где запросы на чтение составляют большую часть нагрузки (например [[API]])


### Чем отличается **WHERE** от **HAVING**

**WHERE**: Применяется для фильтрации строк перед группировкой
([[GROUP BY]]). Используется для отбора строк, которые удовлетворяют определённым условиям

**HAVING**: Применяется после группировки данных с помощью [[GROUP BY]]. Используется для фильтрации групп по агрегированным значениям
([[Агрегатные функции]])(например, `COUNT`, `SUM`, `AVG`)

```sql
SELECT category, COUNT(*)
FROM products
WHERE price > 100
GROUP BY category;
```
Здесь `WHERE` фильтрует строки, где `price > 100`, перед тем как данные будут сгруппированы по категориям

```sql
SELECT category, COUNT(*)
FROM products
GROUP BY category
HAVING COUNT(*) > 10;
```
Здесь `HAVING` фильтрует только те категории, в которых количество товаров больше 10, уже после группировки

#### Можно ли использовать WHERE и HAVING вместе?
Да.Их можно комбинировать:
```sql
SELECT category, COUNT(*)
FROM products
WHERE price > 100
GROUP BY category
HAVING COUNT(*) > 10;
```

### Что такое шардирование?

Шардирование(sharding) это метод горизонтального масштабирования базы данных, где данные разбиваются на несколько частей (шардов) и хранятся на отдельных серверах, это помогает распределить нагрузку

**Горизонтальное шардирование** (Horizontal Sharding)
- Строки таблицы распределяются между шардами
- Пример: Таблица `users` разбивается так, что пользователи с `id` от 1 до 1000 хранятся в одном шарде, от 1001 до 2000 — в другой
**Вертикальное шардирование** (Vertical Sharding)
- Столбцы таблицы разделяются между шардами
- Пример: В одной шарде хранятся данные профилей (`name`, `email`), а в другой — транзакции (`order_id`, `amount`)

#### Недостатки шардирования

**Проблемы с объединением данных**
- Операции вроде `JOIN` и [[GROUP BY]] требуют объединения данных из нескольких шардов, что увеличивает нагрузку
- Транзакции, затрагивающие несколько шардов, становятся сложными и медленными

### Зачем нужны индексы? Привести примеры индексов

[[Индексы]] нужны чтобы ускорить поиск в базе данных

- Индексы могут использоваться для реализации уникальных ограничений, например, в столбцах с `PRIMARY KEY` или `UNIQUE`

Индексы представляют собой структуру данных, такую как **B-Tree** или **Hash**, которая организует значения из столбца (или нескольких столбцов) и связывает их с физическими адресами строк.


**b-tree** это самый часто-используемый индекс, используется по умолчанию в Postgres. В нем значения ищутся при помощи бинарного поиска.

**Hash Индексы**: Используются для поиска по точному значению. Они работают быстрее, чем B-Tree для равенства, но не подходят для диапазонных запросов. Чаще применяются в NoSQL базах данных

#### Что делать если таблица часто обновляется, как работать с индексами в этом случае?

Предположим, у нас есть таблица `orders`, где хранятся заказы. Она обновляется очень часто, так как заказы меняют свой статус (например, `pending`, `completed`, `canceled`)

Что делать, если данные часто обновляются?
- Создавать индексы только для **часто используемых** запросов
- Избегать индексации столбцов, которые **обновляются слишком часто** (например, `status`)
- **Использовать частичные индексы** 
  ```sql
  CREATE INDEX idx_pending_orders ON orders(created_at) WHERE status = 'pending';
```
- Если таблица становится слишком большой, можно разделить её на **части** (**шарды**)(sharding) по ключу, например, `customer_id`.
- **Архивировать старые данные**
  Переносить устаревшие записи (например, заказы старше года) в другую таблицу. Это уменьшит объём данных в основной таблице.



### Что такое составной индекс?

это индекс, который объединяет несколько значений в один уникальный ключ

### Что можно сделать, если упала БД из-за нагрузки?

Оптимизировать запросы. Вертикально или горизонтально масштабировать (Шардирование, Реплицирование) или просто увеличить производительность, балансировать нагрузку

Проверить, что у таблиц есть индексы на часто запрашиваемые поля

### Зачем нужен Foreign Key?

Foreign Key служит для установления связи между двумя таблицами.

### Что такое Агрегатные функции? Привести примеры
[[Агрегатные функции]]

Функции, которые выполняются над группой значений и возвращают единое сводное значение для этой группы. Типичные примеры:   
  
**COUNT  
*SUM  
MIN  
MAX

