
**Тестирование** — важная часть разработки, которая позволяет убедиться, <u>что код работает корректно и изменения не вносят ошибок.</u>Тесты помогают обнаруживать проблемы на ранних этапах, облегчая поддержку и развитие проекта. В Go принято использовать как **юнит-тесты** (unit tests) для проверки отдельных функций и методов, так и **интеграционные тесты** (integration tests) для проверки работы модулей в связке.

- **Юнит-тесты** проверяют небольшие участки кода — обычно одну функцию. Цель юнит-тестов — изолировать и проверить каждую часть программы, чтобы убедиться, что она работает правильно.
- **Интеграционные тесты** проверяют, как различные компоненты приложения взаимодействуют друг с другом. Это особенно важно, если ваше приложение использует базы данных, внешние API или другие сервисы.


***Инструменты и библиотеки для тестирования***
- **testing**: Встроенный пакет Go для написания тестов. С помощью него можно писать юнит и интеграционные тесты. Тесты в Go обычно хранятся в файлах с суффиксом `_`test.go, и функции тестов должны начинаться с **Test**. Например:
```go
func TestSum(t *testing.T) {
    result := Sum(2, 3)
    if result != 5 {
        t.Errorf("Ожидалось 5, получено %d", result)
    }
}
```
- **assert** и **require** из testify: **Testify** — популярная библиотека для тестирования в Go, которая предоставляет удобные функции для утверждений (assertions). Это делает код тестов более читаемым и упрощает их написание. **assert** проверяет условия, не прерывая выполнение теста, а **require** останавливает тест при ошибке. Пример использования:
```go
func TestSum(t *testing.T) {
    result := Sum(2, 3)
    assert.Equal(t, 5, result, "Ожидалось 5")
}
```
- **Моки**: Для тестирования функций, которые зависят от внешних сервисов или сложных объектов, можно использовать моки (заглушки). **Цель моков** — проверить логику тестируемой функции без необходимости взаимодействовать с реальными зависимостями.
Это специальные объекты, которые используются в тестах для имитации поведения реальных зависимостей. Они позволяют изолировать тестируемую часть кода от внешних систем, таких как базы данных, API, файловые системы и другие компоненты.


**Интеграционные тесты** полезны для проверки работы системы в целом. Например, тестирование взаимодействия с базой данных:
```go
import (
    "database/sql"
    "testing"
    _ "github.com/lib/pq"
)

// Интеграционный тест для проверки вставки данных в базу
func TestDatabaseInsert(t *testing.T) {
    // Подключение к базе данных
    db, err := sql.Open("postgres", "user=postgres dbname=test sslmode=disable")
    if err != nil {
        t.Fatalf("Не удалось подключиться к базе данных: %v", err)
    }
    defer db.Close()

    // Выполнение вставки данных
    _, err = db.Exec("INSERT INTO users (name) VALUES ($1)", "Alice")
    if err != nil {
        t.Errorf("Ошибка при вставке данных: %v", err)
    }
}
```
Здесь проверяется, что данные могут быть успешно вставлены в базу. Такой тест позволяет убедиться, что взаимодействие с базой работает корректно.

Пример использования моков для изоляции зависимостей при интеграционном тестировании:
```go
import (
    "testing"
    "github.com/stretchr/testify/mock"
    "github.com/stretchr/testify/require"
)

// Определяем интерфейс и мок для тестирования
type UserService interface {
    GetUser(id int) (string, error)
}

type MockUserService struct {
    mock.Mock
}

func (m *MockUserService) GetUser(id int) (string, error) {
    args := m.Called(id)
    return args.String(0), args.Error(1)
}

func TestGetUser(t *testing.T) {
    mockService := new(MockUserService)
    mockService.On("GetUser", 1).Return("Alice", nil)

    user, err := mockService.GetUser(1)
    require.NoError(t, err)
    require.Equal(t, "Alice", user)
}
```
Здесь используется **testify/mock** для создания мока сервиса, чтобы протестировать функциональность в изоляции, не полагаясь на реальные данные или внешние API.











**Запуск тестов**
Чтобы запустить тесты в Go, используется команда:
```go
go test ./...
```
Эта команда находит все файлы с суффиксом `_test.go` и запускает тесты. Для получения подробной информации о результатах можно добавить флаг `-v` (verbose) и еще можно добавить тестирование отдельнхы тестов ``--run`` ./

- `go test -cover` для оценки покрытия тестами.
- Чтобы увидеть детальную информацию: `go test -coverprofile=coverage.out` и `go tool cover -html=coverage.out`.


**Бенчмарки (Benchmarks)**
Go позволяет измерять производительность кода с помощью бенчмарков. Бенчмарки пишутся в тех же файлах, что и тесты, и начинаются с `Benchmark`. 
``go test -bench=.``