https://habr.com/ru/articles/742402/


В Go сборщик мусора (GC) — отвечает за автоматическое управление памятью. Его задача — освобождать память, занимаемую объектами, которые больше не используются, чтобы избежать утечек памяти

Сборщик мусора основан на алгоритме **маркировки и очистки** (mark-and-sweep). 
- 1. **Стадия маркировки**, начиная с корневого объекта GC проходит по всему дереву объектов и смотрит, какие объекты все еще используются в коде, такие объекты **помечает как 'живые'**
- 2. **Стадия Sweep(очистки)**: Все те объекты, которые не были помечены как 'живые' удаляются из кучи


**Конкурентный** (Concurrent): Сборщик мусора в Go работает параллельно с приложением. Это позволяет избегать длительных пауз, которые бывают у других типов сборщиков, таких как "Stop-the-world". Во время маркировки и зачистки GC может продолжать работать параллельно с горутинами.

**Трехфазный процесс**:
    - **STW (Stop-the-world) Начальная маркировка**: Процесс начинается с короткой паузы, в течение которой определяются корневые объекты. Это так называемая "STW" фаза, но её длительность минимальна. 
    - **Конкурентная маркировка**: На этом этапе GC проходит по всем объектам и отмечает те, которые всё ещё используются.
    - **STW Завершающая маркировка и зачистка**: После завершения маркировки начинается фаза зачистки, в ходе которой память, занятая неиспользуемыми объектами, освобождается.


- **GOGC** — это переменная окружения, которая контролирует частоту запуска GC. Процент новой необработанной памяти кучи от живой памяти. **По умолчанию стоит '100'**, это означает, что GC будет запущен, когда объем новой памяти достигнет 100% от живой. Можно менять эту переменную, например на 1000, тогда будет меньше потребления процессорного времени, но и памяти будет занимать в стеке намного больше.
- **Write Barrier**: В Go используется "Write Barrier" для поддержки конкурентного GC. Это значит, что при изменении ссылок на объекты выполняются дополнительные операции для отслеживания изменений в памяти, что помогает безопасно выполнять маркировку.


**GOMEMLIMIT**(**debug**.**SetMemoryLimit**) - задает общее кол-во памяти, которое RUNTIME может использовать (Не гарантирует на 100% избежания ошибки outOfMemory, однако она откладывает появление этой ошибки)
- Однако мы позволяем программе выходить за этот предел

---
**sync.Pool** - повторное использование временных объектов
Не стоит пихать его куда не нужно, потому что он дорогой

- Управляет объектами определенного типа(создаем отдельный пул на слайсов, int и тд)
- Нет гарантии долгострочного хранения данных, в любой момент GC может посчитать что эти данные нам не нужны и удалить их
- Потокобезопасный, его можно шарить между несколькими горутинами



Arena