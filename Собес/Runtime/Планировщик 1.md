Его основная **задача** — распределять доступные ресурсы (например, процессорное время)

Глобально у планировщика **2 задачи**: спланировать запуск какой-нибудь горутины и взять горутину на исполнение (положить на thead)

#### Какое планирование использует Планировщик?
**Кооперативное** планирование с элементами **вытесняющего**

**Вытесняющее** планирование: Планировщик может принудительно прервать выполнение горутины, если она занимает процессор слишком долго

**Примеры вытесняющего планирования:**
- Если горутина блокируется
	Например, ожидает данные из канала
- Если горутина выполняется слишком долго
	Планировщик принудительно переключает выполнение
- Если горутина завершила свою работу
	Планировщик переходит к следующей в очереди

<u><u>Это предотвращает "захват процессора" одной горутиной, обеспечивая справедливое распределение процессорного времени между всеми горутинами</u></u>

**Кооперативное планирование**: 
Горутина может **добровольно передать управление** планировщику, выполняя операции, которые блокируют её выполнение, например:
- Ожидание ввода/вывода (I/O).
- Системные вызовы ([[Systemcall]], time.Sleep)
- Операции синхронизации (например, `select` или ожидание канала).

#### Модель планировщика
Планировщик использует планирование M:N, где **M** - системные потоки, а **N** - горутины, которые выполняются на системных потоках. **M исполняют N**

![[Pasted image 20250114182036.png]]
Основные элементы:
Верхнеуровнево [[систему планирования M N]] можно описать, используя 3 структуры:

<font color="#9bbb59">M</font>: **Системный поток** исполняющий горутины.
<font color="#9bbb59">G</font>: **Горутина** (Лёгковесная задача, управляемая рантаймом)
<font color="#9bbb59">P</font>: **Processor** (Распределяет задачи между M) и управляет очередью горутин

> [!NOTE]
> M (потоки) исполняют G (горутины), используя P (виртуальные процессоры)

Go использует **несколько очередей** для эффективного выполнения `G`:
1. **Локальные очереди P** – каждая `P` хранит до 256 `G`, чтобы минимизировать блокировки.
2. **Глобальная очередь G** – если у `P` нет работы, она берёт `G` отсюда.
3. **Рабочее воровство (Work Stealing)** – если у `P` много `G`, она отдаёт часть `G` другим `P`.


Горутины это потоки в пользовательском пространстве (user-space thread). Они создаются и управляются рантаймом языка, а не ОС. Они менее ресурснозатратные, чем потоки ОС (user-space threads менее ресурснозатратные) и управляются они планировщиком горутин





- Каждая горутина использует часть оперативной памяти для своего стека ([[Стек и Куча]]) и других данных например: [[Инструкций]]
- По сравнению с системными потоками, стек горутины изначально небольшой (обычно около 2 КБ) и может динамически расширяться



