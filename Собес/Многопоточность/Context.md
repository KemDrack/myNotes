
**Context** — это инструмент для управления временем выполнения операций и передачи данных (сроками жизни между процессами, горутинами или запросами), передачи данных между горутинами, а также для сигналов об отмене операций

Пакет `context` предоставляет несколько видов контекстов, каждый из которых предназначен для конкретных задач

> [!NOTE]
> Любой context должен наследоваться от другого родительского контекста. Исключения: **Background** и **TODO**(заглушка)

![[{21A9882F-9160-482B-A223-AAF19B4D5498} 1.png]]

1.**Background**: Это базовый контекст(начальная точка для других контекстов), обычно используется в качестве корневого контекста. Он не отменяется и не имеет тайм-аута. Чаще всего применяется для инициализации верхнего уровня, например, при запуске приложения

2.**TODO**: Используется, когда не ясно, какой контекст использовать или когда контекст будет определён позже. Это своего рода заглушка для будущих изменений. Работает аналогично `context.Background`

3.**WithCancel**(parent): Этот тип контекста создаёт дочерний контекст с возможностью отмены. Он часто используется для управления завершением горутин. Когда вызывается cancel(), все горутины, использующие этот контекст, должны завершиться
```go
func main() {
    ctx, cancel := context.WithCancel(context.Background())
    defer cancel()

    go func(ctx context.Context) {
        for {
            select {
            case <-ctx.Done():
                fmt.Println("Горутина завершена")
                return
            default:
                fmt.Println("Работа горутины...")
                time.Sleep(1 * time.Second)
            }
        }
    }(ctx)

    time.Sleep(3 * time.Second)
    cancel() // Завершаем горутину через 3 секунды
    time.Sleep(1 * time.Second)
}
```

4.**WithDeadline**(parent, deadline)
Создаёт контекст с конкретной датой и временем, после которых контекст автоматически будет отменён. Это полезно, когда выполнение задачи должно быть завершено к определённому времени
```go
func main() {
    deadline := time.Now().Add(2 * time.Second)
    ctx, cancel := context.WithDeadline(context.Background(), deadline)
    defer cancel()

    select {
    case <-ctx.Done():
        fmt.Println("Контекст завершён: ", ctx.Err())
    }
}
```

5.**WithTimeout**(parent, timeout)
Это обертка над **WithDeadline**. **WithTimeout** внутри себя вызывает **WithDeadline**, где в качестве **Deadline** она использует текущее время, к которому прибавленно значение **Timeout**

Позволяет задать тайм-аут относительно текущего момента. Это удобно для задания максимального времени выполнения задачи.
```go
func main() {
    ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
    defer cancel()

    select {
    case <-ctx.Done():
        fmt.Println("Контекст завершён: ", ctx.Err())
    }
}
```
![[{D84AEDC6-B8D0-4D5A-90A1-B58248318E3E}.png]]

**Пример**: Наше приложение отправляет запрос во внешнюю систему([[API]] другого сервиса), который владеет интересующими нас данными. Мы не можем быть уверены, что API ответит за приемлемое время или вообще ответит когда либо. Чтобы не зависнуть навечно в ожидании ответа API, в запрос можно передать **context**

6.**WithValue**(parent, key, value)
Этот контекст позволяет передавать данные между частями программы. Он используется для хранения информации, необходимой на протяжении выполнения всей операции, например, идентификатор запроса.
```go
func main() {
    ctx := context.WithValue(context.Background(), "userID", 42)

    process(ctx)
}

func process(ctx context.Context) {
    userID := ctx.Value("userID")
    fmt.Printf("User ID: %v\\n", userID)
}
```


*Особенности*:

1.Контексты создаются от родительского. Обычно, контекст создаётся от другого контекста. Например, **WithCancel**() или **WithTimeout**() берут родительский контекст (parent) и создают дочерний. Это позволяет отменить все связанные горутины одновременно.
```go
// Создаём родительский контекст
parentCtx := context.Background() 
// Создаём дочерний контекст с возможностью отмены 
ctx, cancel := context.WithCancel(parentCtx)
----------------------------------------------------------------
ctx, cancel := context.WithCancel(context.Background())
```

2.Контекст всегда передаётся как аргумент функций и горутин.**Копирование контекста** (даже неявное) может нарушить его семантику, потому что создаётся новая ссылка, которая не синхронизирована с механизмами отмены


### Использование в реальной жизни

**Управление тайм-аутами**
- Используется в HTTP-запросах, чтобы запрос автоматически завершался, если он слишком долго выполняется.
**Отмена горутин**
- Контексты позволяют безопасно завершить работу горутин при завершении программ