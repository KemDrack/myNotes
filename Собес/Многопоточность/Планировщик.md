
Его основная задача — распределять доступные ресурсы (например, процессорное время) между активными задачами

Глобально у планировщика **2 задачи**: спланировать запуск какой-нибудь горутины и взять горутину на исполнение (положить на thead)


Планировщик в Go использует **вытесняющее** планирование с элементами **кооперативного**

**Вытесняющее планирование**: Планировщик может **принудительно прервать** выполнение горутины, если она занимает процессор слишком долго

**Примеры вытесняющего планирования:**
- Если горутина блокируется
	Например, ожидает данные из канала
- Если горутина выполняется слишком долго
	Планировщик принудительно переключает выполнение
- Если горутина завершила свою работу
	Планировщик переходит к следующей в очереди

<u><u>Это предотвращает "захват процессора" одной горутиной, обеспечивая справедливое распределение процессорного времени между всеми горутинами</u></u>

**Кооперативное планирование**: 
Горутина может **добровольно передать управление** планировщику, выполняя операции, которые блокируют её выполнение, например:
- Ожидание ввода/вывода (I/O).
- Системные вызовы ([[Systemcall]])
- Операции синхронизации (например, `select` или ожидание канала).

> [!NOTE]
> Горутины лёгкие, и их переключение обходится дешевле, чем переключение потоков ОС
> Планировщик может одновременно управлять миллионами горутин

### **Модель планировщика в Go**

Планировщик Go реализует [[модель M N]], где: