
### Задача 1. Что выведется и как исправить?
```go
func main() {
  var counter int
  for i := 0; i < 1000; i++ {
    go func() {
      counter++
    }()
  }
  fmt.Println(counter)
}
```
Доступ к переменной `counter` из нескольких горутин происходит без синхронизации, что может привести к состоянию гонки **race condition**. Это означает, что несколько горутин могут одновременно читать и изменять значение переменной, что приводит к некорректным результатам
```go
var mu sync.Mutex
var wg sync.WaitGroup

func main() {
    var counter int
    for i := 0; i < 1000; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            mu.Lock()
            counter++
            mu.Unlock()
        }()
    }
    wg.Wait()
    fmt.Println(counter)
}
```
### Задача 2. Что выведет код? Исправить все проблемы
```go
func main() {
	ch := make(chan int)
	wg := &sync.WaitGroup{}
	wg.Add(3)
	for i := 0; i < 3; i++ {
		go func(v int) {
			defer wg.Done()
			ch <- v * v // Отправляем квадрат числа в канал
		}(i) // Передаем i как параметр
	}
	wg.Wait()
	var sum int
	for v := range ch {
		sum += v
	}
	fmt.Printf("result: %d\n", sum)
}
```
На данный момент у нас будет дедлок, потому что мы создаем небуферезированный канал, при записи в который мы ожидаем, что кто-то будет читать из него. Но так как мы запускаем и ждем вейтгруппу, этого не происходит:

Проблема в том, что для range нужен закрытый канал
```go
func main() {
	ch := make(chan int) // Буферизованный канал(3) необязатален
	wg := &sync.WaitGroup{}
	wg.Add(3)

	for i := 0; i < 3; i++ {
		go func(v int) {
			defer wg.Done()
			ch <- v * v // Отправляем квадрат числа в канал
		}(i) // Передаем i как параметр
	}
	go func() {
		wg.Wait()
		close(ch)
	}()

	var sum int
	for v := range ch {
		sum += v
	}
	fmt.Printf("result: %d\n", sum)
}
```

### Что выведет код? Как исправить?
```go
func main() {
	a := 5000
	for i := 0; i < a; i++ {
		go fmt.Println(i)
	}
}
```

Будет неупорядоченный вывод и не факт что все горутины закончат свое выполнение, т.к main функция завершит свое выполнение раньше
```go
func main() {
	a := 5000
	var wg sync.WaitGroup
	wg.Add(a) // Указываем, что нужно ожидать завершения 5000 горутин

	for i := 0; i < a; i++ {
		go func(v int) {
			defer wg.Done() // Уменьшаем счетчик WaitGroup при завершении горутины
			fmt.Println(v)
		}(i) // Передаем значение i в горутину через параметр
	}
	wg.Wait() // Ожидаем завершения всех горутин
}
```

Можем создать пул горутин, что не нагружать планировщик
```go
func main() {
	a := 5000
	numWorkers := 100 // Количество горутин в пуле
	var wg sync.WaitGroup
	wg.Add(a)

	// Канал для передачи задач (значений i)
	tasks := make(chan int, numWorkers)

	// Создаем пул горутин
	for i := 0; i < numWorkers; i++ {
		go func() {
			for v := range tasks {
				fmt.Println(v)
				wg.Done()
			}
		}()
	}

	// Отправляем задачи в канал
	for i := 0; i < a; i++ {
		tasks <- i
	}

	close(tasks) // Закрываем канал после отправки всех задач
	wg.Wait()    // Ожидаем завершения всех задач
}
```

### Задача 3. Будет ошибка, что все горутины заблокированы. Какие горутины заблокированы, и почему?

```go
func main() {
  ch := make(chan int)
  ch <- 1
  go func() {
    fmt.Println(<-ch)
  }()
}
```
Первое решение: небуферизированный канал блокирует основную горутину до тех пор, пока другая горутина не прочитает данные.
```go
func main() {
  ch := make(chan int,1)
  ch <- 1
  go func() {
    fmt.Println(<-ch)
  }()
  time.Sleep(time.Millisecond)
}
```
Второе: Использование WaitGroup
```go
var wg sync.WaitGroup
func main() {
  ch := make(chan int)
  wg.Add(1)
  go func() {
	defer wg.Done()
    fmt.Println(<-ch)
  }()
  ch <- 1
  wg.Wait()
}
```
Если запустить горутину, которая читает данные из канала, перед отправкой данных, это также устранит deadlock.
```go

func main() {
  ch := make(chan int)
  go func() {
    fmt.Println(<-ch)
  }()
  ch <- 1
}
```

### Задача 4. Как это работает? Что не так, как исправить?

Ошибка в коде возникает из-за того, что небуферизированный канал блокирует основную горутину до тех пор, пока другая горутина не прочитает данные. Чтобы исправить это, можно использовать буферизированный канал, изменить порядок выполнения операций или добавить синхронизацию с помощью `sync.WaitGroup`.
```go
func main() {
  ch := make(chan bool)
  ch <- true
  go func() {
    <-ch
  }()
  ch <-true
}
```
--------------------------------------------------------------------
```go 
func main() {
    ch := make(chan bool) // изменить порядок выполнения операций
    go func() {
        <-ch // Чтение первого значения
        <-ch // Чтение второго значения
    }()
    ch <- true
    ch <- true
}

```
--------------------------------------------------------------------
```go 
var wg sync.WaitGroup //Использование WaitGroup
func main() {
    ch := make(chan bool)
    wg.Add(1)
    go func() {
        defer wg.Done()
        <-ch
        <-ch
    }()
    ch <- true
    ch <- true
    wg.Wait()
}
```
--------------------------------------------------------------------
```go
func main() {
    ch := make(chan bool, 1) // Буферизированный канал с размером буфера 1
    ch <- true
    go func() {
        <-ch
    }()
}
```

### Задача 5. Как отработает код? Как сделать так, чтобы выводился только первый ch?

```go
func main() {
        ch := make(chan bool)
        ch2 := make(chan bool)
        ch3 := make(chan bool)
        go func() {
                ch <- true
        }()
        go func() {
                ch2 <- true
        }()
        go func() {
                ch3 <- true
        }()

        select {
        case <-ch:
                fmt.Printf("val from ch")
        case <-ch2:
                fmt.Printf("val from ch2")
        case <-ch3:
                fmt.Printf("val from ch3")
        }
}
```
Решение
```go
func main() {
    ch := make(chan bool)
    go func() {
        ch <- true
    }()
    select {
    case <-ch:
        fmt.Printf("val from ch")
    }
}
```

### Задача 6. Что выведет код и как исправить?

```go
var globalMap = map[string][]int{"test": make([]int, 0), "test2": make([]int, 0), "test3": make([]int, 0)}
var a = 0
 
func main() {
    wg := sync.WaitGroup{}
    wg.Add(3)
    go func() {
        wg.Done()
        a=10
        globalMap["test"] = append(globalMap["test"], a)
         
    }()
    go func() {
        wg.Done()
        a=11
        globalMap["test2"] = append(globalMap["test2"], a)
    }()
    go func() {
        wg.Done()
        a=12
        globalMap["test3"] = append(globalMap["test3"], a)
    }()
    wg.Wait()
    fmt.Printf("%v", globalMap)
    fmt.Printf("%d", a)
}
```

```go
var globalMap = map[string][]int{
    "test":  make([]int, 0),
    "test2": make([]int, 0),
    "test3": make([]int, 0)}
var a = 0
var mu sync.Mutex
func main() {
    wg := sync.WaitGroup{}
    wg.Add(3)
    go func() {
        defer wg.Done()
        a := 10
        mu.Lock()
        globalMap["test"] = append(globalMap["test"], a)
        mu.Unlock()
    }()
    go func() {
        defer wg.Done()
        a := 11
        mu.Lock()
        globalMap["test2"] = append(globalMap["test2"], a)
        mu.Unlock()
    }()
    go func() {
        defer wg.Done()
        a := 12
        mu.Lock()
        globalMap["test3"] = append(globalMap["test3"], a)
        mu.Unlock()
    }()
    wg.Wait()
    mu.Lock()
    fmt.Printf("%v", globalMap)
    mu.Unlock()
    fmt.Printf("%d", a)
}
```
map[test:[10] test2:[11] test3:[12]]

### Задача 7.

### Задача 9. Что выведется, как исправить, как сохранить порядок?
```go
func main() {
  m := make(chan string, 3)
  cnt := 5
  for i := 0; i < cnt; i++ {
    go func() {
      m <- fmt.Sprintf("Goroutine %d", i)
    }()
  }
  for i := 0; i < cnt; i++ {
    go ReceiveFromCh(m)
  }
}
func ReceiveFromCh(ch chan string) {
  fmt.Println(<-ch)
}
```

