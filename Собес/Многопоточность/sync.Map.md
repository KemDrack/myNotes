
Представляет из себя обертку над обычной мапой и [[Mutex]], она нужна для безопасного доступа к данным из мапы горутинами. Т.е только **одна горутина** одновременно может записывать данные в мапу

Структура sync.Map:
```go
type Map struct {
	mu sync.Mutex // мьютекс 

	read atomic.Value // указатель на структуру readOnly // переменные которые можно обновить без мьютекса (быстрое чтение без блокировок)
	dirty map[interface{}]*entry // обычная мапа // для записей, которые были изменены , но ещё не перенесены в `readOnly`.
	misses int
}
type readOnly struct {
	m       map[interface{}]*entry
	amended bool  // Признак наличия записей в dirty
}

type entry struct {
	p unsafe.Pointer // Указатель на значение (хранится атомарно)
}
```

**`mu`:** Используется для синхронизации операций записи и обновления, а также для работы с `dirty` и переносом данных в `readOnly`.
**`read` (атомарное значение):** Это структура `atomic.Value`, которая хранит указатель карты `readOnly`. Чтение из `read` безопасно и не требует блокировки мьютекса.
**`dirty`:** Карта для хранения данных, которые были добавлены или обновлены, но ещё не перенесены в `readOnly`.
**`misses`:** Счётчик "промахов". Он увеличивается, если ключ отсутствует в `readOnly`, но есть в `dirty`. Когда `misses` достигает определённого порога, `dirty` переносится в `readOnly`.

### **Алгоритм работы `sync.Map`**
#### Чтение (`Load`)
1. Проверка ключа в `readOnly`:
    - Если ключ найден, возвращается значение.
    - Если ключ не найден и `amended == true`, то выполняется проверка в `dirty`.
2. Если ключ найден в `dirty`, счётчик `misses` увеличивается.


**Dirty-хранилище:** Используется для записи. Все изменения сначала попадают сюда, а затем могут быть перемещены в `read-only` хранилище

- Использует [[Атомарные операции]] ([[atomic]]) для чтения из `read-only` хранилища.
- Использует мьютексы для операций с `dirty` хранилищем, чтобы гарантировать согласованность данных



### Основные методы `sync.Map`

- **`Store(key, value)`** — добавить или обновить значение по ключу.
- **`Load(key)`** — получить значение по ключу. Возвращает `value, ok`.
- **`LoadOrStore(key, value)`** — если ключ существует, возвращает текущее значение. Если нет, сохраняет новое значение.
- **`Delete(key)`** — удалить ключ и значение.
- **`Range(func(key, value) bool)`** — итерация по всем элемент


### Когда использовать `sync.Map`

1. Большинство операций — это чтение, а записи происходят редко. Это позволяет эффективно использовать `readOnly` для минимизации блокировок.
#### Пример:
- Кэш, который обновляется периодически, но активно используется для чтения.

| Критерий                 | **`sync.Map`**                               | **`map` с `sync.Mutex`**                |
| ------------------------ | -------------------------------------------- | --------------------------------------- |
| **Синхронизация**        | Встроенная                                   | Требуется ручное управление `Mutex`     |
| **Производительность**   | Лучше при большом числе операций чтения      | Лучше при большом числе операций записи |
| **Читаемость кода**      | Упрощённая, не требуется явное управление    | Требуется `Lock` / `Unlock`             |
| **Использование памяти** | Потребляет больше памяти из-за двух хранилищ | Более компактная структура              |

| **Ситуация**                      | **Рекомендация**                 |
| --------------------------------- | -------------------------------- |
| Большинство операций — это чтение | Используйте `sync.Map`           |
| Частые обновления и добавления    | Используйте `map` + `sync.Mutex` |
| Малое количество ключей           | Используйте `map` + `sync.Mutex` |
| Динамическое добавление ключей    | `sync.Map` подходит лучше        |
