
### Что такое Параллельность?
Параллельность - это когда вычисления происходят буквально одновременно, она может достигаться только на процессорах с несколькими ядрами, на разных ядрах в разных потоках

### Что такое асинхронность?

Асинхронность, это когда задачи выполняются не зависимо друг от друга, т.е одна задача может приступить к выполнению не дожидаясь завершения другой задачи. 
В Go асинхронность достигается с помощью **горутин**
**Пример**:
Вы отправляете запрос на сервер, а вместо того, чтобы ждать ответа, программа продолжает выполнять другие действия. Когда ответ от сервера будет готов, программа обработает его
### Что такое конкурентность?
Конкурентность, в отличии от параллельности, это не в буквальном смысле одновременное выполнение нескольких разных задач, а когда на одном ядре процессора очень быстро выполняется переключение между разными задачами, и создается видимость одновременного выполнения.
### Что такое Горутина?
Горутина это легковесный поток, который необходим для написания параллельного кода в ГО, она создается и управляется планировщиком горутин([[планировщикГорутин]]). Так как она легковесная, (минимальный размер 2кб) это делает ее более эффективной в использовании ресурсов по сравнению с обычными системными потоками. Горутины общаются между собой через каналы
### Чем горутна отличается от потока

[[Горутины]] и потоки служат для выполнения кода параллельно

1. Лёгковесность

    [[Горутины]]:
    - Используют **2-4 КБ** памяти на стек при создании.
    - Их стеки **динамически растут** по мере необходимости, начиная с маленького размера.
    - Это позволяет запускать тысячи, а иногда миллионы горутин, без значительного потребления памяти.
	**Потоки:**
    - Используют **1–2 МБ** памяти на стек, выделяемый при создании.
    - Размер стека статичен (если не указано иное), что приводит к переполнению памяти при создании большого количества потоков.
    - Увеличение количества потоков напрямую влияет на потребление ресурсов ОС

2. Управление и планирование
   - Управляются **планировщиком Go**.([[планировщикГорутин]])
 Планировщик Go **экономичен** в переключении между горутинами (меньше затрат на контекстные переключения)
- **Потоки:**
    - Управляются **ядром ОС**.
    - Используют модель **1:1**, где каждый поток соответствует системному потоку.
    - Контекстное переключение между потоками требует обращения к ОС и дороже, чем переключение горутин

### Основные отличия Горутины от Потока

Горутина управляется рантаймом языка ([[Планировщик]]ом), когда поток управляется процессором. Горутина не зависит от системы и более легковесна. Также можно сказать что количество горутин практически не ограниченно, потому что они создаются в оперативной памяти.

### Что такое Thread(Поток)?
Поток это реализация вычислений физического процессора
[[планировщикГорутин]]

### Что такое [[Планировщик]] / **Scheduler** (Описать принцип работы)
Планировщик отвечает за управление горутинами в рантайме, он распределяет ресурсы и определяет порядок их выполнения   
  
Планировщик поддерживает очередь готовых к выполнению горутин, и когда горутина становится готова (Например, заканчивается блокирующая операция), она добавляется в эту очередь
### Виды **Context**
[[Context]]
**Background**: Обычно используется в главной функции, инициализации приложения и тестах, как базовый контекст  
  
**TODO**: Используется, когда не ясно, какой контекст использовать или когда контекст будет определён позже 

**WithCancel**: Создаёт контекст, который может быть отменён вручную  
  
**WithDeadline**: Создаёт контекст с временной границей, после которой он отменяется  
  
**WithTimeout**: Похож на WithDeadline, но позволяет указать таймаут вместо конкретного времени

**WithValue**(parent, key, value)
Этот контекст позволяет передавать данные между частями программы. Он используется для хранения информации, необходимой на протяжении выполнения всей операции, например, идентификатор запроса.
### Что нельзя передавать в **контекст**?
В контекст не следует передавать данные большого размера или чувствительные данные. Контексты предназначены для передачи сигналов (например, отмены) и небольших метаданных. Использование контекста для передачи значительных данных может привести к усложнению кода и даже проблемам с производительностью
### Отличие между context.Background() и context.TODO()

context.**Background**() используется как основной контекст, который служит начальной точкой для всех других контекстов. context.**TODO**() используется в тех местах, где пока не ясно, какой контекст должен быть использован. Это сигнал разработчику о необходимости уточнить контекст позже

### Что лучше не передавать в **контекст** со значением?

В контекст лучше не передавать значительные или изменяющиеся данные. Контекст предназначен для хранения небольших статических данных, таких как идентификаторы запросов, токены и т.д. Если в контексте хранить большие данные, это усложняет управление и снижает читаемость.

### Для чего используется **Context**?

Для передачи данных и управления сроками жизни между процессами, горутинами или запросами. Для сигналов об отмене операций

### Какие примитивы **синхронизации** есть в GO?

- [[Mutex]]
Он предотвращает одновременное выполнение нескольких горутин в критической секции
- [[RWmutex]]
- [[WaitGroup]]
Используется для синхронизации выполнения горутин, позволяя основной программе ожидать их завершения
- [[atomic]]
Для простых числовых операций без необходимости сложной блокировки
- [[Каналы]]
Передача данных между горутинами
- [[sync.Map]]
sync.Map эффективен в системах, где большинство операций — это чтение данных. При большом количестве часто обновляемых ключей, лучше использовать `map` с `sync.Mutex`.
- Context ?
Контроль времени жизни горутин (таймауты, отмена)

### Что такое **race condition** / гонка данных?
**Race condition** - состояние, когда несколько горутин пытаются изменить или прочитать из одной переменной. Так как любые операции над переменными не атомарные (выполняются не за одну операцию) может произойти так, что одна горутина УВЕЛИЧИТ переменную, но не успеет сохранить эти изменения, и в этот же момент другая горутина ПРОЧИТАЕТ старые данные, и опять УВЕЛИЧИТ на то же значение

### Что такое **deadlock**?

**Deadlock** (взаимная блокировка) — это состояние, при котором несколько горутин (или процессов) блокируют друг друга, ожидая освобождения ресурсов, которые уже заняты друг другом 
**Deadlock** возникает, когда каждая из горутин удерживает ресурс, необходимый другой, и никто из них не может продолжить выполнение


### Что такое **семафор** и **воркерпул**?

**Семафор**: ограничивает доступ к ресурсу, контролируя количество активных потоков (Ограничение параллелизма)
Он позволяет нескольким горутинам или потокам одновременно получить доступ к ограниченному количеству "разрешений"

Изначально у семафора есть заданное количество "разрешений" (например, 3).

<u>Для реализации семафора в Go можно использовать каналы</u>
```go
func main() {
    const maxWorkers = 3 // Максимальное количество разрешений
    sem := make(chan struct{}, maxWorkers) // Семафор
    var wg sync.WaitGroup

    tasks := []int{1, 2, 3, 4, 5} // Список задач

    for _, task := range tasks {
        wg.Add(1)
        go func(task int) {
            defer wg.Done()
            sem <- struct{}{} // Захватываем разрешение
            fmt.Printf("Выполняется задача %d\n", task)
            time.Sleep(2 * time.Second) // Симуляция работы
            fmt.Printf("Задача %d завершена\n", task)
            <-sem // Освобождаем разрешение
        }(task)
    }
    wg.Wait()
    fmt.Println("Все задачи завершены")
}
```
- Канал **sem** ограничивает число одновременно работающих горутин (до `maxWorkers`)
- Горутины блокируются, если канал заполнен

**Воркерпул**: пул горутин, распределяющий задачи для экономии ресурсов(Балансировка нагрузки)
#### Как работает Worker Pool

- Создаётся **пул горутин** ("воркеров"), которые ожидают задачи
- Задачи добавляются в общую очередь
- Воркер извлекает задачу из очереди, выполняет её, затем переходит к следующей
- Когда все задачи выполнены, воркеры завершают свою работу

```go
// Воркер, выполняющий задачу
func worker(id int, tasks <-chan int, wg *sync.WaitGroup) {
    defer wg.Done()
    for task := range tasks {
        fmt.Printf("Воркер %d: выполняет задачу %d\n", id, task)
        time.Sleep(1 * time.Second) // Симуляция работы
        fmt.Printf("Воркер %d: завершил задачу %d\n", id, task)
    }
}

func main() {
    const numWorkers = 3 // Количество воркеров
    tasks := make(chan int, 10) // Очередь задач
    var wg sync.WaitGroup

    // Запускаем воркеров
    for i := 1; i <= numWorkers; i++ {
        wg.Add(1)
        go worker(i, tasks, &wg)
    }

    // Добавляем задачи в очередь
    for i := 1; i <= 10; i++ {
        tasks <- i
    }

    close(tasks) // Закрываем канал задач, чтобы воркеры знали, что задачи закончились

    wg.Wait()
    fmt.Println("Все задачи выполнены")
}
```

### Что такое Graceful Shutdown?

Корректное завершение приложения с ожиданием завершения текущих операций
**В Go**: используют [[Context]] и sync.[[WaitGroup]]

#### Зачем нужен Graceful Shutdown

**Избежание потери данных**: Позволяет завершить выполнение текущих операций (например, обработка HTTP-запросов или транзакций в БД)

**Освобождение ресурсов:**: Закрытие открытых файлов, соединений с базами данных, сокетов и других ресурсов.

#### Как работает Graceful Shutdown
1. Приложение получает [[Systemcall]](**например**, SIGTERM или SIGINT) и запускает процедуру завершения
2. **Завершение текущих задач**: Сервер перестаёт принимать новые запросы, но завершает обработку уже начатых
3. **Освобождение ресурсов**: Закрытие файлов, соединений с базами данных, остановка горутин и т.д

### В каком порядке вызывается **defer** ?

[[Defer]] добавляет переданную после него функцию в стек, который работает по принципу LIFO (Last In First Out), поэтому функции вызовуются в обратном порядке

### Для чего используется **atomic**?

[[atomic]] - предоставляет набор атомарных функций, реализованных на аппаратном уровне. Это позволяет избегать гонки данных без блокировок. Вместе с этим, с помощью `atomic` в отличие от [[Mutex]] можно делать только простые вещи, к примеру инкрементировать различные счетчики

### Для чего используют [[Mutex]] и какие бывают?

При помощи мьютекса мы можем ограничить доступ к данным для разных горутин и избежать race condition

- `sync.Mutex` - блокирует кусок кода как на запись, так и на чтение
- `sync.RWMutex` - позволяет блокировать кусок кода только на запись

Мьютексы решают проблему гонки данных, это когда несколько горутин одновременно пытаются читать и писать в одну переменную, например, увеличивать ее, и так как операция увеличения у нас не атомарная, то есть она выполняется не за один шаг, а за три (Чтение, увеличение, запись). так вот, в момент когда одновременно несколько горутин пытаются увеличивать одно и тоже число, одна из них может находится на этапе увеличения, но не дойти до записи, в то время как вторая горутина прочитает старое значение, и опять увеличит его. В следствии чего и возникает гонка данных.  
  
так вот, при помощи мьютекса мы можем ограничить доступ к данным для разных горутин и избежать такой ситуации.

### Что такое [[WaitGroup]]?

**Вейтгруп** это реализация счетчика, который мы можем увеличивать или уменьшать ( .add(1) ), который используется для синхронизации кода. Например, мы можем остановить выполнение кода, пока значение счетчика не станет равным нулю.

### Как общаются горутины?

Горутины "общаются" через передачу нужных данных при помощи **каналов**

**Буферизованные каналы**:
- Позволяют отправлять данные, пока буфер не заполнен, без немедленного чтения
**Небуферизованные каналы**:
- Отправка данных блокирует горутину до тех пор, пока данные не будут прочитаны из канала

### Какие есть способы **остановить все горутины**?

1. Завершение **main** функции и **main** **горутины  
2. Завязать все горутины на переданный в них [[Context]]
Инструмент для управления временем жизни горутин. Он поддерживает сигналы отмены (`cancel`) и тайм-ауты (`timeout`).
```go
func worker(ctx context.Context) {
    for {
        select {
        case <-ctx.Done(): // Проверяем, завершён ли контекст
            fmt.Println("Горутина завершена")
            return
        default:
            fmt.Println("Работа горутины")
            time.Sleep(500 * time.Millisecond)
        }
    }
}
func main() {
    ctx, cancel := context.WithCancel(context.Background())
    go worker(ctx)

    time.Sleep(2 * time.Second)
    cancel() // Отправляем сигнал завершения
    time.Sleep(1 * time.Second)
}
```
3. Чтение всеми горутинами из определенного канала, который при **закрытии** отправит (сигнал) значение по умолчанию, и горутины сделают return
```go
func worker(stop chan struct{}) {
    for {
        select {
        case <-stop: // Получаем сигнал завершения
            fmt.Println("Горутина завершена")
            return
        default:
            fmt.Println("Работа горутины")
            time.Sleep(500 * time.Millisecond)
        }
    }
}
func main() {
    stop := make(chan struct{})
    go worker(stop)

    time.Sleep(2 * time.Second) // Ждём немного
    close(stop)                 // Отправляем сигнал завершения
    time.Sleep(1 * time.Second) // Даем время горутине завершиться
}
```

### Для чего используется **Sync** **Map**?

[[sync.Map]] представляет из себя обертку над обычной мапой и Mutex'а, она нужна для безопасного доступа к данным из мапы горутинами. Т.е только одна горутина одновременно может записывать данные в мапу.   
  
Структура sync.Map:
```go
type Map struct {
	mu sync.Mutex // мьютекс 

	read atomic.Value // указатель на структуру readOnly // переменные которые можно обновить без мьютекса
	dirty map[interface{}]*entry // обычная мапа
	misses int
}
type readOnly struct {
	m       map[interface{}]*entry
	amended bool 
}
```


### Какое **максимальное** количество горутин?

Максимальное количество горутин ограниченно оперативной памятью

Максимум горутин ≈ Доступная память​ / Размер стека

```go
func main() {
	count := 0
	for {
		go func() {
			select {} // Горутина ничего не делает, только висит
		}()
		count++
		if count%10000 == 0 {
			fmt.Printf("Создано горутин: %d\n", count)
		}
	}
}
```

### Какой максимальный **размер горутины**? (Стека), что будет, если она превысит этот размер?

Для **64** битной системы - 1гб, для **32ух** - 250мб. Если стек горутины превысил максимально допустимое значение, то наше приложения крашнется с fatal error

```go
GODEBUG=runtime.maxstack=SIZE
```
где `SIZE` — максимальный размер стека в байтах.


