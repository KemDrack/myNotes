#горутины #каналы



Каналы являются фундаментальным примитивом синхронизации и коммуникации между горутинами в языке Go. Они обеспечивают эффективный способ передачи данных, позволяя организовывать конкурентное программирование без явных блокировок и сложных механизмов синхронизации.

- Не буферизованный канал — это канал, в котором нет "места для хранения данных". Это значит, что когда одна горутина отправляет данные в канал, она **блокируется** (ждет), пока другая горутина не примет это значение. То есть отправка и прием происходят одновременно.
- Если кто-то пытается отправить значение в не буферизованный канал, а никто не принимает его в этот момент, отправка будет ждать.

### Пример использования

### Не буферизованный канал:

```go
ch := make(chan int)

go func() {
    ch <- 42 // Блокируется, пока кто-то не примет это значение
}()

value := <-ch // Получает значение 42 и разблокирует отправителя
```

Здесь отправитель (`ch <- 42`) будет ждать, пока кто-то не примет значение (`value := <-ch`). Это удобно для синхронизации, когда отправка и прием должны происходить одновременно.

### Буферизованный канал:

```go
bufferedCh := make(chan int, 10)

bufferedCh <- 1 // Не блокируется, так как в буфере есть свободное место
bufferedCh <- 2 // Не блокируется
```

Здесь мы можем отправить 10 значений в `bufferedCh` подряд без блокировки. Только когда буфер будет заполнен, отправка будет блокироваться, пока кто-то не прочитает данные из канала.

### Основная идея

- **Не буферизованные каналы** — синхронизируют отправку и получение.
- **Буферизованные каналы** — позволяют отправлять и принимать данные, пока буфер не заполнен или не пуст.

## Внутреннее Устройство Каналов (Исходный код)

```go
type hchan struct {
	qcount   uint           // total data in the queue`
	dataqsiz uint           // size of the circular queue`
	buf      unsafe.Pointer // points to an array of dataqsiz elements`
	elemsize uint16
	closed   uint32
	timer    *timer // timer feeding this chan`
	elemtype *_type // element type`
	sendx    uint   // send index`
	recvx    uint   // receive index`
	recvq    waitq  // list of recv waiters`
	sendq    waitq  // list of send waiters`

	// lock protects all fields in hchan, as well as several`
	// fields in sudogs blocked on this channel.`
	//`
	// Do not change another G's status while holding this lock`
	// (in particular, do not ready a G), as this can deadlock`
	// with stack shrinking.`
	lock mutex
}
```


### Очереди Ожидания

Если горутина пытается отправить данные в полный канал или получить из пустого, она добавляется в очередь ожидания (`sendq` или `recvq`). Когда место освобождается, горутина продолжает выполнение.

## База

Каналы в Go — это тип данных для передачи значений определённого типа между горутинами. Их создают с помощью функции `make`, например:

```go
ch := make(chan int)  // Небуферизованный канал
bufferedCh := make(chan int, 10) // Буферизованный канал с ёмкостью 10
```

Отправка и получение через канал осуществляются оператором ←:

```go
ch <- 42        // Отправка значения (блокируется, если нет получателя)
value := <- ch   // Получение значения (блокируется, если нет отправителя)
```

**Небуферизованные каналы** блокируют отправителя, пока получатель не примет значение, и наоборот. **Буферизованные каналы** позволяют отправлять данные без блокировки, пока буфер не заполнен, и получать без блокировки, пока буфер не пуст.

## Операции с каналами

### Создание канала

```go
ch := make(chan Type)          // Небуферизованный канал
ch := make(chan Type, capacity) // Буферизованный канал
```

### Отправка в канал

```go
ch <- value // Блокируется, если канал заполнен или небуферизован и нет получателя
```

### Получение из канала

```go
value := <- ch // Блокируется, если канал пуст или небуферизован и нет отправителя
```

### Закрытие канала

```go
close(ch) // Закрывает канал для дальнейшей отправки
```

- После закрытия канала отправка в него приводит к панике.
- Получение из закрытого канала продолжает работать:
    - Возвращает оставшиеся значения из буфера.
    - Затем возвращает нулевое значение типа канала и `false`.

### Проверка закрытия канала

```go
value, ok := <- ch
if !ok {
    // Канал закрыт и больше нет данных
}
```

## Чтение из канала

### Прямое присваивание

```go
value := <- ch
```

### Цикл `for range`

```go
for value := range ch {
    // Обработка значения
}
```
Можем применять только при закрытом канале
Цикл завершается, когда канал закрыт и все значения прочитаны.

### Использование `select`

```go
select {
case value := <- ch:
    // Обработка значения
default:
    // Действие по умолчанию, если нет данных
}
```


## Вопросы с собеседований

- В чем разница между буферизованными и небуферизованными каналами?
    
    - **Небуферизованные каналы** требуют одновременного участия отправителя и получателя
    - **Буферизованные каналы** позволяют отправителю продолжать работу, пока буфер не заполнен, и получателю читать данные, пока буфер не пуст.
- Как закрыть канал и зачем это нужно?
    
    - **Как**: Использовать функцию `close(ch)`.
    - **Зачем**: Сигнализировать получателям, что больше данных не будет отправлено. Это позволяет корректно завершить цикл чтения из канала.
- Что произойдет при попытке отправки в закрытый канал?
    
    - **Результат**: Возникает паника (`panic`).
    - **Рекомендация**: Убедиться, что канал открыт перед отправкой, или структурировать программу так, чтобы отправка происходила до закрытия.
- Как проверить, закрыт ли канал?
    
    - **При получении**: Использовать второе возвращаемое значение.
    
    ```go
    value, ok := <- ch
    if !ok {
        // Канал закрыт
    }
    ```
    
- Какой порядок выполнения операций в `select`?
    
    - **Порядок не гарантируется**.
    - Если несколько каналов готовы, `select` выбирает случайный `case`
- Как можно читать из канала?
    
    1. Напрямую через ←
    2. При помощи `for * := range chan`
    3. При помощи `select`
- Как горутины общаются между собой?
    
    При помощи каналов
    
- Как сделать `select` неблокирующим?
    
    - **Добавить блок `default`**:
    
    ```go
    select {
    case value := <- ch:
        // Обработка значения
    default:
        // Действие по умолчанию
    }
    ```
    
- Что будет если писать или читать из nil channel?
    
    Горутина заблокируется навсегда


## Лайфкодинг

- **Задача 1**
    
    ### Будет ошибка, что все горутины заблокированы. Какие горутины заблокированы, и почему? Как исправить?
    
    ```go
    package main
    
    import "fmt"
    
    func main() {
      ch := make(chan int)
      ch <- 1
      go func() {
        fmt.Println(<-ch)
      }()
    }
    ```
    
- **Задача 2**
    
    ### Как это работает? Что не так, как исправить?
    
    ```go
    func main() {
      ch := make(chan bool)
      ch <- true
      go func() {
        <-ch
      }()
      ch <-true
    }
    ```
    
- **Задача 3**
    
    ### Как отработает код? Как сделать так, чтобы выводился только первый ch?
    
    ```go
    func main() {
            ch := make(chan bool)
            ch2 := make(chan bool)
            ch3 := make(chan bool)
            go func() {
                    ch <- true
            }()
            go func() {
                    ch2 <- true
            }()
            go func() {
                    ch3 <- true
            }()
    
            select {
            case <-ch:
                    fmt.Printf("val from ch")
            case <-ch2:
                    fmt.Printf("val from ch2")
            case <-ch3:
                    fmt.Printf("val from ch3")
            }
    }
    ```
    
- Задача 4
    
    ### Merge N channels, если один из каналов закрывается, нужно закрыть остальные
    
    ```go
    func case3(channels ...chan int) chan int {
    }
    ```
    
- Доп материалы
    
    > **Самое лучшее что вы можете сделать для реально ГЛУБОКО понимания работы любой структуры рантайма - ознакомиться с ее исходным кодом:**
    
    [***](https://go.dev/src/runtime/chan.go)[https://go.dev/src/runtime/chan.go***](https://go.dev/src/runtime/chan.go***)
    
    [**GopherCon 2017: Kavya Joshi - Understanding Channels**](https://youtu.be/KBZlN0izeiY)