#горутины #каналы

Каналы — это тип данных для передачи значений определённого типа между горутинами

- Небуферизованный канал — это канал, в котором нет "места для хранения данных". Это значит, что когда одна горутина отправляет данные в канал, она **блокируется** (ждет), пока другая горутина не примет это значение. То есть отправка и прием происходят одновременно.
- Если кто-то пытается отправить значение в не буферизованный канал, а никто не принимает его в этот момент, отправка будет ждать.

Небуферизованные каналы нужны для передачи данных между горутинами




```go
ch := make(chan int)

go func() {
    ch <- 42 // Блокируется, пока кто-то не примет это значение
}()

value := <-ch // Получает значение 42 и разблокирует отправителя

Буферизованный канал
bufferedCh := make(chan int, 10)

bufferedCh <- 1 // Не блокируется, так как в буфере есть свободное место
bufferedCh <- 2 // Не блокируется
```
## Внутреннее Устройство Каналов
```go
type hchan struct {
	qcount   uint    // кол-во элементов в буфере 
	dataqsiz uint   // размерность буфера
	buf      unsafe.Pointer // Ссылка на сам буфер
	elemsize uint16 // размер одного элемента в буфере (в байтах)
	closed   uint32 // Флаг(закрыт ли канал) uint32 а не bool, потому что атомики не могут работать с bool, единственное что нам доступно это uint32. Мы будем изменять его состояние не блокируя канал 
	timer    *timer // таймер для операций с каналом
	elemtype *_type // (для проверки типов при отправке/получении
	sendx    uint   // номера ячеек буфера из которых произв запись данных 
	recvx    uint   // номер ячейки в буфере из которой будет производиться чтение данных 
	recvq    waitq  // очередь горутин, ожидающих чтения
	sendq    waitq  // очередь горутин, ожидающих записи в канал
	
	lock mutex // защищает от гонок данных
}
Когда в канале освободится место (например, данные будут прочитаны другой горутиной), горутины из `sendq` будут "разбужены"

```
waitq: Хранит ссылки на начало и конец [[связного списка]]
```go
type waitq struct {
	first *sudog
	last *sudog
}
type sudog struct {
	g *g // Та самая спящая горутина
	elem unsafe.Pointer // элемент, который мы собираемся отправить ... если же горутина хочет не записать, а прочитать данные из канала, то тут бы хранилась ссылка на ячейку памяти, в которую эти данные нужно положить 
}
```
Здесь `sudog` — это структура, которая представляет заблокированную горутину.

---

*Аксиомы небуферизированного канала*

|          | Открытый                                                    | Закрытый                                         | Nil                                |
| -------- | ----------------------------------------------------------- | ------------------------------------------------ | ---------------------------------- |
| Чтение   | <font color="#f79646">блокировка до прихода писателя</font> | <font color="#00b050">вернется zero value</font> | блокировка навсегда                |
| Запись   | <font color="#f79646">блокировка до прихода читателя        | <font color="#ff00</font>00">panic               | блокировка н</font>авсегда         |
| Закрытие | <font color="#00b050">закроется</font>                      | <font color="#ff0000">panic</font>               | <font color="#ff0000">panic</font> |

*Аксиомы буферизированного канала*

|        | Открытый и частично<br>заполненный                   | Открытый и полностью<br>заполненный                  | Открытый и<br>пустой                                 | Закрытый<br>и частично<br>заполненный                           | Закрытый<br>и пустой |
| ------ | ---------------------------------------------------- | ---------------------------------------------------- | ---------------------------------------------------- | --------------------------------------------------------------- | -------------------- |
| Чтение | <font color="#00b050">прочитаем<br>значение          | <font color="#00b050">прочитаем<br>значение          | <font color="#f79646">блокировка до прихода писателя | <font color="#00b050">прочитаем<br>значение                     |                      |
| Запись | <font color="#00b050">запишем<br>значение</font><br> | <font color="#f79646">блокировка до прихода читателя | <font color="#00b050">запишем<br>значение</font>     | <font color="#ff0000">panic                             </font> |                      |
*Канал только на чтение и запись*

| <font color="#4bacc6">Read chan</font> |                   | <font color="#4bacc6">Write chan</font> |                   |
| -------------------------------------- | ----------------- | --------------------------------------- | ----------------- |
| Запись                                 | Ошибка компиляции | Чтение                                  | Ошибка компиляции |
| Закрытие                               | Ошибка компиляции |                                         |                   |


---

**Как поставить горутину на паузу?** 
**gopark()** - функция Go, которая приостанавливает (блокирует) текущую горутину. Она обращается к планировщику, который изменяет состояние горутины из running в waiting. Далее он разрывает связь горутины с ее thead, таким образом thead становится свободным
**goready()** - занимается пробуждением горутин
**sendDirect()** - нужна для оптимизации, данные перемещаются из стека одной горутины в стек другой. Одна горутина получается доступ к стеку другой. Чтобы не копировать данные


**Select**
- **select** блокирует горутину, пока хотя бы один из `case` блоков не станет готовым к выполнению
- Если несколько `case` готовы одновременно, `select` выбирает один из них **случайным образом**
- Если добавить `default`, `select` не будет блокироваться. Если ни один `case` не готов, выполнится `default`

**select** часто используется с `time.After` для реализации таймаутов.
```go
select {
case <-ch:
    fmt.Println("data received")
case <-time.After(2 * time.Second):
    fmt.Println("timeout") // Сработает через 2 секунды, если ch не готов
}
```

**Небуферизованные каналы** блокируют отправителя(горутину), пока получатель не примет значение, и наоборот. **Буферизованные каналы** позволяют отправлять данные без блокировки, пока буфер не заполнен, и получать без блокировки, пока буфер не пуст.
### Проверка закрытия канала
```go
value, ok := <- ch
if !ok {
    // Канал закрыт и больше нет данных
}
```


