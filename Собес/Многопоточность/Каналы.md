#горутины #каналы

Каналы — это тип данных для передачи значений определённого типа между горутинами

- Не буферизованный канал — это канал, в котором нет "места для хранения данных". Это значит, что когда одна горутина отправляет данные в канал, она **блокируется** (ждет), пока другая горутина не примет это значение. То есть отправка и прием происходят одновременно.
- Если кто-то пытается отправить значение в не буферизованный канал, а никто не принимает его в этот момент, отправка будет ждать.
```go
ch := make(chan int)

go func() {
    ch <- 42 // Блокируется, пока кто-то не примет это значение
}()

value := <-ch // Получает значение 42 и разблокирует отправителя

Буферизованный канал
bufferedCh := make(chan int, 10)

bufferedCh <- 1 // Не блокируется, так как в буфере есть свободное место
bufferedCh <- 2 // Не блокируется
```
## Внутреннее Устройство Каналов
```go
type hchan struct {
	qcount   uint    // кол-во элементов в буфере 
	dataqsiz uint   // размерность буфера
	buf      unsafe.Pointer // Ссылка на сам буфер
	elemsize uint16 // размер одного элемента в буфере (в байтах)
	closed   uint32 // Флаг(закрыт ли канал) uint32 а не bool, потому что атомики не могут работать с bool, единственное что нам доступно это uint32. Мы будем изменять его состояние не блокируя канал 
	timer    *timer // таймер для операций с каналом
	elemtype *_type // (для проверки типов при отправке/получении
	sendx    uint   // номера ячеек буфера из которых произв запись данных 
	recvx    uint   // номер ячейки в буфере из которой будет производиться чтение данных 
	recvq    waitq  // очередь горутин, ожидающих чтения
	sendq    waitq  // очередь горутин, ожидающих записи в канал
	
	lock mutex // защищает от гонок данных
}
Когда в канале освободится место (например, данные будут прочитаны другой горутиной), горутины из `sendq` будут "разбужены"

```
waitq: Хранит ссылки на начало и конец [[связного списка]]
```go
type waitq struct {
	first *sudog
	last *sudog
}
type sudog struct {
	g *g // Та самая спящая горутина
	elem unsafe.Pointer // элемент, который мы собираемся отправить ... если же горутина хочет не записать, а прочитать данные из канала, то тут бы хранилась ссылка на ячейку памяти, в которую эти данные нужно положить 
}
```
Здесь `sudog` — это структура, которая представляет заблокированную горутину.

**Как поставить горутину на паузу?** 
**gopark()** - функция Go, которая приостанавливает (блокирует) текущую горутину. Она обращается к планировщику, который изменяет состояние горутины из running в waiting. Далее он разрывает связь горутины с ее thead, таким образом thead становится свободным
**goready()** - занимается пробуждением горутин
**sendDirect()** - нужна для оптимизации, данные перемещаются из стека одной горутины в стек другой. Одна горутина получается доступ к стеку другой. Чтобы не копировать данные


**Select**
- **select** блокирует горутину, пока хотя бы один из `case` блоков не станет готовым к выполнению
- Если несколько `case` готовы одновременно, `select` выбирает один из них **случайным образом**
- Если добавить `default`, `select` не будет блокироваться. Если ни один `case` не готов, выполнится `default`

**select** часто используется с `time.After` для реализации таймаутов.
```go
select {
case <-ch:
    fmt.Println("data received")
case <-time.After(2 * time.Second):
    fmt.Println("timeout") // Сработает через 2 секунды, если ch не готов
}
```

**Небуферизованные каналы** блокируют отправителя(горутину), пока получатель не примет значение, и наоборот. **Буферизованные каналы** позволяют отправлять данные без блокировки, пока буфер не заполнен, и получать без блокировки, пока буфер не пуст.
### Проверка закрытия канала

```go
value, ok := <- ch
if !ok {
    // Канал закрыт и больше нет данных
}
```

## Чтение из канала

### Цикл `for range`

```go
for value := range ch {
    // Обработка значения
}
```
Можем применять только при закрытом канале
Цикл завершается, когда канал закрыт и все значения прочитаны.

### Использование `select`

```go
select {
case value := <- ch:
    // Обработка значения
default:
    // Действие по умолчанию, если нет данных
}
```


## Вопросы с собеседований

- В чем разница между буферизованными и небуферизованными каналами?
    
    - **Небуферизованные каналы** требуют одновременного участия отправителя и получателя
    - **Буферизованные каналы** позволяют отправителю продолжать работу, пока буфер не заполнен, и получателю читать данные, пока буфер не пуст.
- Как закрыть канал и зачем это нужно?
    
    - **Как**: Использовать функцию `close(ch)`.
    - **Зачем**: Сигнализировать получателям, что больше данных не будет отправлено. Это позволяет корректно завершить цикл чтения из канала.
- Что произойдет при попытке отправки в закрытый канал?
    
    - **Результат**: Возникает паника (`panic`).
    - **Рекомендация**: Убедиться, что канал открыт перед отправкой, или структурировать программу так, чтобы отправка происходила до закрытия.
- Как проверить, закрыт ли канал?
    
    - **При получении**: Использовать второе возвращаемое значение.
    
    ```go
    value, ok := <- ch
    if !ok {
        // Канал закрыт
    }
    ```
    
- Какой порядок выполнения операций в `select`?
    
    - **Порядок не гарантируется**.
    - Если несколько каналов готовы, `select` выбирает случайный `case`
- Как можно читать из канала?
    
    1. Напрямую через ←
    2. При помощи `for * := range chan`
    3. При помощи `select`
- Как горутины общаются между собой?
    
    При помощи каналов
    
- Как сделать `select` неблокирующим?
    
    - **Добавить блок `default`**:
    
    ```go
    select {
    case value := <- ch:
        // Обработка значения
    default:
        // Действие по умолчанию
    }
    ```
    
- Что будет если писать или читать из nil channel?
    
    Горутина заблокируется навсегда


## Лайфкодинг

- **Задача 1**
    
    ### Будет ошибка, что все горутины заблокированы. Какие горутины заблокированы, и почему? Как исправить?
    
    ```go
    package main
    
    import "fmt"
    
    func main() {
      ch := make(chan int)
      ch <- 1
      go func() {
        fmt.Println(<-ch)
      }()
    }
    ```
    
- **Задача 2**
    
    ### Как это работает? Что не так, как исправить?
    
    ```go
    func main() {
      ch := make(chan bool)
      ch <- true
      go func() {
        <-ch
      }()
      ch <-true
    }
    ```
    
- **Задача 3**
    
    ### Как отработает код? Как сделать так, чтобы выводился только первый ch?
    
    ```go
    func main() {
            ch := make(chan bool)
            ch2 := make(chan bool)
            ch3 := make(chan bool)
            go func() {
                    ch <- true
            }()
            go func() {
                    ch2 <- true
            }()
            go func() {
                    ch3 <- true
            }()
    
            select {
            case <-ch:
                    fmt.Printf("val from ch")
            case <-ch2:
                    fmt.Printf("val from ch2")
            case <-ch3:
                    fmt.Printf("val from ch3")
            }
    }
    ```
    
- Задача 4
    
    ### Merge N channels, если один из каналов закрывается, нужно закрыть остальные
    
    ```go
    func case3(channels ...chan int) chan int {
    }
    ```
    
- Доп материалы
    
    > **Самое лучшее что вы можете сделать для реально ГЛУБОКО понимания работы любой структуры рантайма - ознакомиться с ее исходным кодом:**
    
    [***](https://go.dev/src/runtime/chan.go)[https://go.dev/src/runtime/chan.go***](https://go.dev/src/runtime/chan.go***)
    
    [**GopherCon 2017: Kavya Joshi - Understanding Channels**](https://youtu.be/KBZlN0izeiY)