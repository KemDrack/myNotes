Master остаётся единственным источником правды для записей, а Slave — для распределения нагрузки на чтение

Когда данные изменяются на сервере **Master** (вставка, удаление, обновление), эти изменения записываются в Log(**журнал транзакций**) (Write-Ahead Log, [[WAL в PostgreSQL]])
**Master отправляет лог на Slave:**
- Master передаёт обновления из своего журнала транзакций на серверы Slave, Slave получает логи изменений и применяет их локально
Slave отвечает на запросы, используя локальную копию данных, полученную от Master
---
Как происходит **Выбор лидера**:
- Алгоритм забияки
Мы можем каждой реплике задать ранг -> договориться на берегу
0 -> 1 -> 2 -> 3 -> 4 -> 5. Если реплика с весом "5" вышла из строя. Узел, который синкается с репликой, он смотрит, так, 5 недоступен и он сразу раскидывает выборы тем узлам, которые выше его рангом. те "4" получит выбор и начнет раскидывать только тем узлам, которые выше ее рангом, "3" тоже получила этот сигнал и раскидывает сигнал только тем, кто выше рангом. В итоге "4" останется сама на себе и поймет, что она главная, после этого она раскидывает всем репликам Event, что она самая главная
В `etcd` можно **хранить ранги узлов** и **выбирать нового лидера** на основе их значений
- Raft(Используется **etcd**)
- Paxos
---
<font color="#9bbb59">Маршрутизация запросов(Балансировка)</font>
Чтобы клиенты отправляли запросы именно на Slave:

1. Используются **балансировщики нагрузки** ([[load balancer]]), которые направляют запросы на нужный сервер
2. Приложение может быть настроено так, чтобы отправлять:
- Все записи на Master
- Все чтения на Slave


---
Синхронная и асинхронная репликация