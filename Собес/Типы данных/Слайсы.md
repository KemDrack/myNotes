[[Лайфкодинг]]
[[Вопросы]]

Слайс — это динамический массив. Он состоит из:
- **Указателя на массив**
- **Длины (len)** — количество элементов в слайсе.
- **Емкости (cap)** — максимальное количество элементов, которое может в себя местить низлежайший массив.

Массив имеет фиксированную длину, а slice — динамическую.
```go
slice := make([]int, 3, 5) // len(slice) == 3, cap(slice) == 5
```

Слайс сам по себе не хранит данных, а только указывает на массив, где данные находятся

```go
package runtime

type slice struct {
    array unsafe.Pointer
    len   int    
    cap   int
}
```

Когда ёмкость слайса превышена, используется функция *growslice* для выделения новой области памяти:
```go
func growslice(oldPtr unsafe.Pointer, newLen, oldCap, num int, et *_type) slice {
    newcap := nextslicecap(newLen, oldCap) // используем функцию nextslicecap
    p := mallocgc(newcap * et.Size_, et, true)
    memmove(p, oldPtr, oldLen * et.Size_)
    return slice{p, newLen, newcap}
}
```
Мы видим, что в строчке **newcap** мы определяем новую **capacity** при помощи функции **nextslicecap**. Вот ее исходный код:

```go
func nextslicecap(newLen, oldCap int) int {
    newcap := oldCap
    doublecap := newcap + newcap  // Увеличиваем емкость в 2 раза
    if newLen > doublecap {
        return newLen  // Если новый размер больше удвоенной емкости, вернем его
    }

    const threshold = 256  // Порог для смены метода увеличения
    if oldCap < threshold {
        return doublecap  // Если емкость меньше порога, удваиваем её
    }
    for {
        // Переходим к увеличению на 1.25x для больших слайсов
        newcap += (newcap + 3*threshold) >> 2  // Увеличиваем емкость на 25%

        // Проверяем, хватит ли новой емкости и нет ли переполнения
        if uint(newcap) >= uint(newLen) {
            break  // Если всё ок, выходим
        }
    }

    // Если произошло переполнение, возвращаем новый размер
    if newcap <= 0 {
        return newLen
    }
    return newcap  // Возвращаем новую емкость
}
```

## `append()`

- Если в слайсе достаточно емкости, `append()` добавляет элементы в текущий массив.
- Если _**capacity**_ превышена, создаётся новый массив с **`cap`** в 2 раза больше(при > 256 на 25% больше) и элементы из старого массива копируются в новый

## Ньюансы работы со слайсами

- **Общий массив для нескольких слайсов**: Разные слайсы могут указывать на один и тот же массив. Это может привести к неожиданным изменениям данных.
    
    ```go
    arr := [5]int{1, 2, 3, 4, 5}
    slice1 := arr[1:4]
    slice2 := arr[2:5]
    slice1[1] = 10 // меняет arr и slice2
    ```
    
- **Изменение ссылки при добавлении элементов**: Когда вы используете `append()` для добавления элементов, может создаться новый слайс. Этот новый слайс уже не будет связан с исходным массивом.

