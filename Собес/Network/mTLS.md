
**mTLS** — это когда не только клиент проверяет сертификат сервера (как в обычном HTTPS), но и сервер проверяет сертификат клиента. Оба должны доверять друг другу (точнее, удостоверяющему центру - CA, который выдал их сертификаты). Это стандартный способ обеспечить аутентификацию и шифрование для service-to-service коммуникации

**Создать свой внутренний CA**
Vault. Мы создаем корневой сертификат CA (ca.crt) и его приватный ключ (ca.key). *
**Использовать Service Mesh:** Инструменты типа Istio или Linkerd


**Где Хранить Сертификаты и Ключи:**
- **Kubernetes Secrets:** Самый распространенный способ в K8s. Сертификаты и ключи кладутся в секреты и монтируются как файлы в поды сервисов.
- **Vault**
- **Файлы на сервере (менее гибко):** Если не K8s, то файлы кладутся на ВМ при деплое (например, через Ansible), с правильными правами доступа.

**Настроить Сервер (Принимающий сервис, например, CalculateService):**
Нужно сконфигурировать его HTTP-сервер (в Go это http.Server) так, чтобы он:
- Использовал свой сертификат (calculate-service.crt) и ключ (calculate-service.key)
- Знал и доверял корневому сертификату вашего CA (ca.crt) для проверки сертификатов клиентов
- Требовал от клиентов предоставлять сертификат и проверял его (tls.RequireAndVerifyClientCert)

- **Настроить Клиент (Вызывающий сервис, например, PolicyService):**
Нужно сконфигурировать его HTTP-клиент (в Go это http.Client) так, чтобы он:
- Использовал свой сертификат (policy-service.crt) и ключ (policy-service.key) при установке соединения.
- Знал и доверял корневому сертификату вашего CA (ca.crt) для проверки сертификата сервера.


**Важно:** Настроив mTLS, вы обеспечиваете аутентификацию сервиса. CalculateService теперь знает, что запрос пришел от доверенного PolicyService. Но он все еще не знает, от имени какого пользователя действует PolicyService. Поэтому контекст пользователя (User ID или JWT) все равно нужно передавать в заголовках, как обсуждалось ранее.