
**Когда использовать синхронное взаимодействие (REST/gRPC)?**
- **Немедленный ответ:** Когда вызывающий сервис (PolicyService) не может продолжить свою работу без ответа от вызываемого сервиса (CalculateService). В примере с расчетом цены, PolicyService должен получить цену сейчас, чтобы показать ее пользователю или инициировать оплату на конкретную сумму. Он не может просто отправить событие в Kafka и ждать неизвестно сколько.
- **Запрос-Ответ:** Когда взаимодействие по своей природе является прямым запросом данных или выполнением команды с ожиданием результата.
- **Простота (для простых случаев):** Иногда реализация простого REST-вызова проще, чем настройка топиков, продюсеров, консьюмеров и логики обработки асинхронных ответов в Kafka.

**Когда использовать асинхронное взаимодействие (Kafka)?**
- **Отложенная обработка:** Когда вызывающему сервису не нужен немедленный результат (например, отправка уведомления, запуск фоновой задачи классификации).
- **Декаплинг (Слабая связанность):** Сервисы не зависят от доступности друг друга в реальном времени. Если NotificationService временно недоступен, событие просто подождет в Kafka.
- **Событийная архитектура (Event-Driven):** Когда нужно оповестить несколько подписчиков о произошедшем событии (например, PolicyRenewed может быть интересно и NotificationService, и AnalyticsService).
- **Высокая пропускная способность:** Kafka отлично справляется с большим потоком событий.

**Это безопасно (прямое взаимодействие по сети)?**
- **Да, если сделано правильно.** Безопасность обеспечивается на нескольких уровнях
    - **Сетевая изоляция:** Микросервисы должны работать в **приватной, доверенной сети** (например, внутри Kubernetes кластера). Их внутренние API не должны быть доступны извне напрямую, только через API Gateway.
    - **Шифрование (опционально, но рекомендуется):** Внутри сети можно использовать TLS (часто **mTLS - mutual TLS**, где сервисы проверяют сертификаты друг друга) для шифрования трафика между сервисами. Service Mesh (Istio, Linkerd) могут помочь настроить это прозрачно.
    - **Аутентификация/Авторизация сервисов:** Даже внутри сети один сервис должен убедиться, что другой сервис имеет право его вызывать. Это можно делать через mTLS или передавая какой-то внутренний токен/API-ключ. Также важно передавать контекст пользователя (User ID, роли), полученный от Gateway, чтобы сервис мог проверить права конечного пользователя.
- **Риски:** Если внутренняя сеть не защищена, или нет аутентификации между сервисами, то скомпрометированный сервис может получить несанкционированный доступ к другим.