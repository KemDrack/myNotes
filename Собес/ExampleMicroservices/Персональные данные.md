

Хранить ПДн в открытом виде в основной базе данных микросервиса — плохая практика и часто является нарушением закона

- **Хэширование (Hashing):** Это **односторонний** процесс. Из хэша невозможно восстановить исходные данные. Хэширование (с солью, используя стойкие алгоритмы вроде bcrypt, scrypt, Argon2) **идеально подходит для паролей**. Вы храните хэш пароля, и при логине хэшируете введенный пользователем пароль и сравниваете хэши. Вы никогда не храните сам пароль и не можете его восстановить.
- **Шифрование (Encryption):** Это **двусторонний** процесс. Данные шифруются с помощью ключа, и их можно расшифровать, зная ключ. Подходит для ПДн, которые нужно будет получить в исходном виде (имя, email, адрес).
- **Токенизация (Tokenization):** Это процесс замены чувствительных данных на нечувствительный эквивалент — **токен**. Оригинальные данные безопасно хранятся в "хранилище" (том самом PII Vault), а токен используется в других системах. Чтобы получить исходные данные, нужно обратиться в хранилище с токеном. По сути, это то, что вы описали. Токен сам по себе не несет информации о данных.




Пример работы сервиса:
- Пользователь вводит свои ПДн (имя, email, телефон) в интерфейсе, который общается, например, с UserService.
        
    - UserService получает эти ПДн.
    - UserService **не сохраняет** ПДн в свою базу данных. Вместо этого он отправляет ПДн (например, по защищенному каналу вроде HTTPS/gRPC с TLS) в PiiVaultService.
    - PiiVaultService валидирует данные, **шифрует** их надежным алгоритмом (например, AES-GCM) с использованием ключа, который хранится максимально безопасно (например, в HSM или специализированном Key Management Service - KMS).
    - PiiVaultService сохраняет зашифрованные данные в своей защищенной базе данных.
    - PiiVaultService генерирует уникальный, нечувствительный **токен** (например, UUID), который ссылается на сохраненные зашифрованные данные.
    - PiiVaultService возвращает этот **токен** UserService.
    - UserService сохраняет этот **токен** в своей базе данных рядом с ID пользователя (например, в поле pii_token). Сами ПДн (имя, email) в базе UserService отсутствуют.
        
- **Получение данных (например, для отправки email):**
    
    - NotificationService должен отправить пользователю письмо. Ему нужен email пользователя.
    - NotificationService знает ID пользователя. Он может запросить у UserService токен ПДн для этого пользователя.
    - UserService находит пользователя по ID и возвращает pii_token.
    - NotificationService берет pii_token и отправляет запрос в PiiVaultService (например, GET /pii/{pii_token}?fields=email).
    - PiiVaultService проверяет права доступа NotificationService (авторизация!).
    - PiiVaultService находит запись по токену, **расшифровывает** нужные поля (только email в данном случае) с помощью ключа.
    - PiiVaultService возвращает расшифрованный email NotificationService.
    - NotificationService использует email для отправки письма и **не сохраняет** его у себя надолго (использует по назначению и "забывает").


- Используем **KMS** или Vault для хранения ключа
- **PiiVaultService** должен строго проверять, кто (какой сервис) к нему обращается и имеет ли он право на доступ к данным конкретного пользователя или конкретным полям. Используйте mTLS, JWT, OAuth или другие механизмы.
- **Гранулярность данных:** PiiVaultService может позволять запрашивать только определенные поля ПДн (например, только email, а не все данные сразу), чтобы следовать принципу минимально необходимых данных