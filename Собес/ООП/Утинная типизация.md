
**Утиная типизация** — это концепция, которая утверждает: "Если что-то **выглядит** как утка, **плавает** как утка и **крякает** как утка, то, скорее всего, это утка". 

Это означает, что объект не обязательно должен явно принадлежать какому-либо определённому типу. Главное, чтобы он имел определённый **набор методов**, которые ожидаются от него.

**Так работает реализация интерфейса**. Если тип реализует все методы интерфейса, он автоматически удовлетворяет этому интерфейсу

То есть мы не проверяем, является ли объект формально "уткой", а смотрим только на его поведение (методы).
### Пример:
```go
// Интерфейс
type Flyer interface {
	Fly()
}

// Структура
type Bird struct {
	Name string
}

// Метод для структуры Bird
func (b Bird) Fly() {
	fmt.Printf("%s летит\n", b.Name)
}

// Ещё одна структура
type Airplane struct {
	Model string
}

// Метод для структуры Airplane
func (a Airplane) Fly() {
	fmt.Printf("Самолёт %s летит\n", a.Model)
}

// Функция принимает любой тип, который реализует интерфейс Flyer
func LetItFly(f Flyer) {
	f.Fly()
}

func main() {
	bird := Bird{Name: "Воробей"}
	plane := Airplane{Model: "Боинг 747"}

	// Оба объекта можно передать в функцию, так как они реализуют метод Fly()
	LetItFly(bird)   // Воробей летит
	LetItFly(plane)  // Самолёт Боинг 747 летит
}
```



