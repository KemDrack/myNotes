
Парадигма программирования, основанная на объектах, которые инкапсулируют данные (состояние) и поведение (методы). Основные принципы: инкапсуляция, наследование, полиморфизм.

Go не является полностью ООП языком в привычном смысле. Однако, ключевые концепции ООП (поддерживаются через свои уникальные механизмы

**Инкапсуляция**:
<u>Объединение данных (состояния) и методов (поведения) в одном объекте</u>
В Go инкапсуляция достигается с помощью **экспортируемых** (публичных) и **неэкспортируемых** (приватных) идентификаторов
```go
type User struct { 
	Name string // Экспортируемое поле 
	age int // Приватное поле 
}
```

**Наследование**(композиция):
<u>Возможность одного объекта унаследовать свойства и методы другого для повторного использования кода</u>
Наследование позволяет одному типу включать в себя другой тип и использовать его методы.
Т.е все **методы**, которые относятся к Animal **наследуются** другой структурой, которая указала ее как поле
```go
type Animal struct {
    Name string
}

func (a Animal) Speak() {
    fmt.Println(a.Name, "говорит!")
}

type Dog struct {
    Animal // Встраиваем Animal
}

func main() {
    d := Dog{Animal{Name: "Бобик"}}
    d.Speak() // Dog унаследовал метод Speak от Animal
}
```

**Полиморфизм**:
<u>Способность объектов одного интерфейса иметь разные реализации</u>
В Go полиморфизм достигается через **[[Интерфейсы]]**.
Интерфейс определяет **набор методов**, которые должны быть типом, чтобы соответствовать этому интерфейсу.
Реализация интерфейса происходит автоматически, если тип **содержит** необходимые **методы**
```go
type Speaker interface {
    Speak()
}

type Human struct{}

func (h Human) Speak() {
    fmt.Println("Привет!")
}

type Robot struct{}

func (r Robot) Speak() {
    fmt.Println("Бип-бип!")
}

func saySomething(s Speaker) {
    s.Speak()
}

func main() {
    h := Human{}
    r := Robot{}
    saySomething(h)
    saySomething(r)
}
```