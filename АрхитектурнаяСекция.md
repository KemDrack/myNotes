[[Необходимо спроектировать архитектуру бекенда для мессенджера (Slack, Teams, Mattermost)]]


[[Transactional Outbox]]
Вопросы
Архитектурная секция I
1. **как называется этот паттерн? (transactional outbox)**
Позволяет гарантированно сохранять события в БД, а потом асинхронно их обрабатывать
- Используется, когда синхронный вызов стороннего сервиса (например, аналитики) может зависнуть.
2. **опиши на псевдокоде алгоритм работы job-ы, которая разгребает outbox**
```
rows := select id, payload from outbox WHERE status = 'pending' ORDER BY created_at LIMIT 50 FOR UPDATE SKIP LOCKED
    for row in rows:
    SET status = 'processing' WHERE id = row.id; # Блокируем запись
    push_to_analytics

	if success: DELETE FROM outbox WHERE id = row.id; # Удаляем запись после успешной отправки 
	else: 
	SET status = 'failed' WHERE id = row.id;

sleep(5)

- Выбираем необработанные записи.
- Обновляем статус на `"processing"`, чтобы другие Job-ы не забрали ту же запись.
- Пытаемся отправить данные в аналитику.
- Если отправка успешна** → удаляем запись.
- Если ошибка → помечаем `"failed"` и пробуем снова через время.

```
1. **какие есть виды гарантий доставки сообщений?**
- At most once (не более одного раза)
    - Сообщение может потеряться, но не дублируется.
    - Пример: UDP-запросы, простая отправка без подтверждения.
- At least once (не менее одного раза)
    - Сообщение может дублироваться, но не теряется.
    - Пример: Kafka, RabbitMQ с подтверждением (`ack`).
- Exactly once (ровно один раз)
    - Сообщение обрабатывается гарантированно один раз.
1. **как реализовать exactly once?**
Используем уникальные идентификаторы сообщений (`message_id`)
- Перед обработкой проверяем было ли уже обработано это сообщение:


Архитектурная секция II
1. сервис Б не справляется с нагрузкой, что делать?
Горизонтальное масштабирование - запустить **несколько экземпляров B**.
**Кэширование**
**Балансировка нагрузки**( Envoy, Kubernetes Service).
**Асинхронная обработка** (`Kafka` вместо синхронных HTTP-запросов)
1. ок, мы подняли 2 сервиса Б, как реализовать балансировку нагрузки по http между ними?

2. какие алгоритмы балансировки нагрузок ты знаешь?
- **Round Robin** (по кругу)
- **Least Connections** (меньше всего активных соединений)
- **IP Hash** (один клиент всегда попадает на один сервер)
- **Weighted Round Robin** (взвешенное распределение)
- **Random** (случайное распределение запросов)
1. какие есть недостатки у серверной балансировки?
Балансировщик **увеличивает `latency`**
Балансировщик — точка отказа, **Решение**: используем **несколько балансировщиков**.
1. ок, мы подняли 2 балансировщика нагрузок, как клиент узнаёт к кому из них обращаться?
У всех балансировщиков **один IP**, но маршрутизатор отправляет запрос **на ближайший**

1. как клиент узнаёт адреса серверных балансировщиков?
В DNS **записываются несколько IP-адресов балансировщиков**.
**Fixed List (Статический конфиг)**
- Клиенту **жёстко задан список балансировщиков** (`config.yaml`).





Фронт -->  А ---http-->  Б

Тебя пригласили руководителем команды в финтех стартап
У твоей команды 2 микросервиса - А без БД и Б с БД

1. Сервис А и Б участвуют в процессе выдачи кредита
2. В сервис А, через цепочку других микросервисов приходит запрос с фронта
3. Сервис А отправляет запрос в Б по HTTP
4. Каждый из этих сервисов работает на своем физическом сервере (1 инстанс)

Кейсы
1. Сервис А не справляется с нагрузкой - CPU 100% в пиковую нагрузку (Добавить инстансы и LB)
2. Что делать если сеть нестабильная, вероятность прохождения запроса по сети от A до B - 90% (ретраи) , а нужно --> 99.99%
3. 90 к/м -> 100 к/м; 1% --> 6 %, Система А обрабатывала 90 кредитов в минуту, а стала 100. При этом процент кредитов, которые погасили в первый же день вырос с 1% до 6, после добавления ретраев. Что делать?

4. Все упало. И первым поднялись инстансы сервиса А, которые отправляют запросы на Б. С Б происходит следующая ситуация:
    1. Поднмиает инстанс 1 сервиса Б 
    2. Идут запросы с сервиса А
    3. Инстанс 1 не справляется с запросами - CPU 100%
    4. LB отключает инстанс 1
и так по кругу. Что делать?

1. ---------------------------------------
      --> ... А (3 инстанса) ---(50 рпс)-->    
                                  
Фронт --> ... А (3 инстанса) ---(50 рпс)-->     D
      
      --> ... А (3 инстанса) ---(50 рпс)--> 
У нас есть внешняя платная система D, которая может обрабатывать максимум 150 rps. Если мы превышаем этот лимит, то на сервис А и фронт возвращается ошибка плюс мы будем должны заплатить доп бабки. Что сделать, чтобы мы не превышали этот лимит. (3 датацентра с 3 инстансами на каждый. Желательно не добавлять сервисы,которые будут работать только на 1 инстансе. При этом он зачел ответ, что я буду считать количество запросов с помощью редиса)

![[{FD2572C2-3C89-43C0-8353-B870F676B97C}.png]]
