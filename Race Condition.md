**Race condition** — возникает возможность появления неправильных результатов из-за неудачной временной координации потоков, когда результат зависит от таймингов между потоками

**Пример**
```go
x := 0  
for {   
	go func() {  
	  //mu.Lock()
      x++ // Одна горутина делает запись
      //mu.Unlock()
   }()   
   go func() {  
      //mu.Lock()
      if x%2 == 0 {  // Вторая одновременно читает
         time.Sleep(1 * time.Millisecond)  
         fmt.Println(x)
      }
      //mu.Unlock()
   }()  
}
```
В результате на консоле получим четные и нечетные числа, а расчитывали увидеть только четные
*Мы проверили `x%2 == 0`, но пока ждали (Sleep), горутина с `x++` успела изменить `x` на нечётное*
Это и есть **race condition** — несинхронизированный доступ к разделяемой переменной
Эту проблему мы можем решить Mutex или локальной копией переменной
```go
x := 0  
for range 1000 {  //for i := 0; i < 1000; i++
   go func() {  
      x++  
   }()  
   go func() {  
      y := x  
      if y%2 == 0 {  
         time.Sleep(1 * time.Millisecond)  
         fmt.Println(y)  
      }  
   }()  
}
```

**Второй пример**
```go
func main() {
	go os.Remove("temp.txt")
	go os.Open("temp.txt")
}
```
Одна горутина удаляет файл, другая пытается его открыть. Какой поток выполнится первым — непредсказуемо. Это **race condition**, потому что поведение зависит от порядка выполнения




