[[Вопросы с собеседовний(Redis)]]

Redis Cluster
**Redis** (Remote Dictionary Server) — это высокопроизводительная база данных(in memory), которая полностью работает в **оперативной памяти**, что обеспечивает сверхвысокую скорость операций

Обычно хранят наименее ответственные данные или данные, которые имеют определенный срок жизни, потерять которые не столь критично 

Данные могут периодически сохраняться на диск для восстановления

Он поддерживает запись данных на диск для обеспечения надёжности и может использоваться как кэш, брокер сообщений, база данных или шина данных

**Основные сценарии использования:**
<font color="#9bbb59">Кэширование</font>:
- Redis часто используется для хранения временных данных (результаты вычислений, HTML-страницы, токены аутентификации)
- Благодаря низкой задержке (обычно менее 1 мс) Redis позволяет ускорить доступ к часто запрашиваемым данным
<font color="#9bbb59">Очереди задач:</font>  !!!
- Redis поддерживает структуры данных, такие как списки и наборы, которые идеально подходят для реализации очередей задач
<font color="#9bbb59">Работа с потоками данных:</font>
- Redis может использоваться для обработки событий и сообщений в реальном времени
<font color="#9bbb59">Сессии и токены:</font>
- Хранение данных сессий или JWT токенов, поскольку Redis предоставляет встроенные механизмы TTL (время жизни ключей)

## Поддерживаемые типы данных:

1. **Строки** (Strings):
- Простая структура для хранения текста или бинарных данных.
- Применение: кэширование строк, счётчики, токены.
- Команды: `SET`, `GET`, `INCR`, `DECR`.

| Команда                        | Описание                                                 | Пример                            |
| ------------------------------ | -------------------------------------------------------- | --------------------------------- |
| `SET key value`                | Устанавливает значение `value` для ключа `key`.          | `SET user:1 "John Doe"`           |
| `GET key`                      | Получает значение ключа.                                 | `GET user:1` → `John Doe`         |
| `DEL key`                      | Удаляет ключ и его значение.                             | `DEL user:1`                      |
| `INCR key`                     | Увеличивает числовое значение ключа на 1.                | `INCR counter` → `1`              |
| `DECR key`                     | Уменьшает числовое значение ключа на 1.                  | `DECR counter` → `-1`             |
| `APPEND key value`             | Добавляет строку `value` к существующему значению ключа. | `APPEND user:1 " Doe"`            |
| `STRLEN key`                   | Возвращает длину строки значения ключа.                  | `STRLEN user:1` → `8`             |
| `MSET key1 val1 key2 val2 ...` | Устанавливает значения для нескольких ключей.            | `MSET user:1 "John" user:2 "Doe"` |
| `MGET key1 key2 ...`           | Получает значения для нескольких ключей.                 | `MGET user:1 user:2` → `John Doe` |

2. **Хэши (Hashes)**: (похожие на JSON)
    - Ассоциативные массивы для хранения объектов.
    - Применение: хранение пользовательских профилей.
    - Команды: `HSET`, `HGET`, `HGETALL`

| Команда                             | Описание                                  | Пример                              |
| ----------------------------------- | ----------------------------------------- | ----------------------------------- |
| `HSET key field value`              | Устанавливает поле в хэше.                | `HSET user:1 name "John"`           |
| `HGET key field`                    | Получает значение поля.                   | `HGET user:1 name` → `John`         |
| `HGETALL key`                       | Получает все поля и значения.             | `HGETALL user:1` → `name John`      |
| `HDEL key field`                    | Удаляет поле из хэша.                     | `HDEL user:1 name`                  |
| `HEXISTS key field`                 | Проверяет, существует ли поле.            | `HEXISTS user:1 name` → `1`         |
| `HLEN key`                          | Возвращает количество полей.              | `HLEN user:1` → `1`                 |
| `HINCRBY key field increment`       | Увеличивает значение поля на `increment`. | `HINCRBY user:1 age 1`              |
| `HMSET key field1 val1 field2 val2` | Устанавливает несколько полей в хэше.     | `HMSET user:1 name "John" age "30"` |
3. **Списки (Lists)**:
    - Последовательность упорядоченных элементов
    - Применение: очереди задач, ленты новостей.
    - Команды: `LPUSH`, `RPUSH`, `LPOP`, `RPOP`.

| Команда                | Описание                                         | Пример                              |
| ---------------------- | ------------------------------------------------ | ----------------------------------- |
| `LPUSH key value`      | Добавляет значение в начало списка.              | `LPUSH tasks "Task1"`               |
| `RPUSH key value`      | Добавляет значение в конец списка.               | `RPUSH tasks "Task2"`               |
| `LPOP key`             | Удаляет и возвращает первый элемент списка.      | `LPOP tasks` → `Task1`              |
| `RPOP key`             | Удаляет и возвращает последний элемент списка.   | `RPOP tasks` → `Task2`              |
| `LRANGE key start end` | Возвращает элементы списка в заданном диапазоне. | `LRANGE tasks 0 -1` → `Task1 Task2` |
| `LLEN key`             | Возвращает длину списка.                         | `LLEN tasks` → `2`                  |
| `LINDEX key index`     | Возвращает элемент по индексу.                   | `LINDEX tasks 0` → `Task1`          |
| `LSET key index value` | Устанавливает значение элемента по индексу.      | `LSET tasks 0 "UpdatedTask1"`       |
| `LREM key count value` | Удаляет `count` элементов, равных `value`.       | `LREM tasks 1 "Task1"`              |
4. **Множества (Sets)**:
    - Неупорядоченные коллекции уникальных элементов.
    - Применение: хранение уникальных пользователей, тегов.
    - Команды: `SADD`, `SREM`, `SMEMBERS`.

|Команда|Описание|Пример|
|---|---|---|
|`SADD key value`|Добавляет элемент в множество.|`SADD tags "redis"`|
|`SMEMBERS key`|Возвращает все элементы множества.|`SMEMBERS tags` → `redis`|
|`SREM key value`|Удаляет элемент из множества.|`SREM tags "redis"`|
|`SISMEMBER key value`|Проверяет, есть ли элемент в множестве.|`SISMEMBER tags "redis"` → `1`|
|`SCARD key`|Возвращает количество элементов множества.|`SCARD tags` → `1`|
|`SDIFF key1 key2`|Возвращает разность двух множеств.|`SDIFF set1 set2`|
|`SINTER key1 key2`|Возвращает пересечение множеств.|`SINTER set1 set2`|
|`SUNION key1 key2`|Возвращает объединение множеств.|`SUNION set1 set2`|
5. **Упорядоченные множества (Sorted Sets)**:
    - Коллекции элементов с приоритетами (весами).
    - Применение: рейтинги, системы рекомендаций.
    - Команды: `ZADD`, `ZRANGE`, `ZREM`.

|Команда|Описание|Пример|
|---|---|---|
|`ZADD key score value`|Добавляет элемент с весом.|`ZADD leaderboard 100 "Alice"`|
|`ZRANGE key start end`|Возвращает элементы в диапазоне индексов.|`ZRANGE leaderboard 0 -1`|
|`ZREVRANGE key start end`|Возвращает элементы в обратном порядке.|`ZREVRANGE leaderboard 0 -1`|
|`ZSCORE key value`|Возвращает вес элемента.|`ZSCORE leaderboard "Alice"`|
|`ZRANK key value`|Возвращает индекс элемента.|`ZRANK leaderboard "Alice"`|
|`ZREMRANGEBYRANK key start end`|Удаляет элементы по диапазону индексов.|`ZREMRANGEBYRANK leaderboard 0 1`|
6. **Потоки (Streams)**:
    - Используются для хранения и обработки событий в реальном времени.
    - Применение: обработка логов, интеграция микросервисов.
    - Команды: `XADD`, `XREAD`, `XGROUP`

7. **Pub/Sub** для организации системы публикации/подписки(Может использоваться как брокер сообщений)

|Команда|Описание|Пример|
|---|---|---|
|`PUBLISH channel message`|Публикует сообщение в канал.|`PUBLISH news "Hello"`|
|`SUBSCRIBE channel`|Подписывается на канал.|`SUBSCRIBE news`|
|`UNSUBSCRIBE channel`|Отписывается от канала.|`UNSUBSCRIBE news`|
## <font color="#9bbb59">Бэкапы:</font>

**Redis** может сохранять данные на диск, чтобы обеспечить их сохранность при перезапуске. Есть два основных механизма:
- **RDB (Redis Database Backup)**: Периодическое(раз в час допустим) создание снимков (snapshots) данных.
- **AOF (Append-Only File)**: Логирование каждой операции записи для восстановления данных. В нем так таковой необходимости нет, т.к у нас есть реплики
Используем **RDB**

Redis поддерживает репликацию [[Master - Slave]], где данные автоматически синхронизируются между серверами.
Главное, что есть реплики и чтобы мы совсем потеряли данные у нас должен сначала упасть **Master**, потом **реплика** и еще одна **реплика**, пока этого не произошло у нас какая то копия данных, очень свежая

### Redis vs. Memcached
- **Redis**: Поддерживает множество структур данных, устойчив к отказам.
- **Memcached**: Более простое решение для кэширования только строковых данных.
### Redis vs. SQL
- Redis используется для временных данных, где важна скорость. SQL обеспечивает сложные запросы и долговременное хранение.

## Redis предоставляет инструменты для управления конкурентным доступом к данным:

1. **Транзакции**:
    - Группы команд выполняются атомарно.
    - Команды: `MULTI`, `EXEC`.
2. **Механизмы блокировки**:
    - Redis может использоваться для реализации распределённых блокировок с помощью команд `SETNX` (set if not exists).


### TTL и автоматическое удаление

Redis поддерживает **время жизни** ключей (TTL), что делает его идеальным инструментом для **временного хранения** данных. Команды:
- `EXPIRE`: Устанавливает время жизни ключа.
- `TTL`: Проверяет оставшееся время жизни ключа.
Пример использования:
- Хранение временных токенов аутентификации
