

### Чем горутна отличается от потока

[[Горутины]] и потоки служат для выполнения кода параллельно

1. Лёгковесность

    [[Горутины]]:
    - Используют **2-4 КБ** памяти на стек при создании.
    - Их стеки **динамически растут** по мере необходимости, начиная с маленького размера.
    - Это позволяет запускать тысячи, а иногда миллионы горутин, без значительного потребления памяти.
	**Потоки:**
    - Используют **1–2 МБ** памяти на стек, выделяемый при создании.
    - Размер стека статичен (если не указано иное), что приводит к переполнению памяти при создании большого количества потоков.
    - Увеличение количества потоков напрямую влияет на потребление ресурсов ОС

2. Управление и планирование
   - Управляются **планировщиком Go**.([[планировщикГорутин]])
 Планировщик Go **экономичен** в переключении между горутинами (меньше затрат на контекстные переключения)
- **Потоки:**
    - Управляются **ядром ОС**.
    - Используют модель **1:1**, где каждый поток соответствует системному потоку.
    - Контекстное переключение между потоками требует обращения к ОС и дороже, чем переключение горутин

### Виды Context
[[Context]]
**Background**: Обычно используется в главной функции, инициализации приложения и тестах, как базовый контекст  
  
**TODO**: Используется, когда не ясно, какой контекст использовать или когда контекст будет определён позже 

**WithCancel**: Создаёт контекст, который может быть отменён вручную  
  
**WithDeadline**: Создаёт контекст с временной границей, после которой он отменяется  
  
**WithTimeout**: Похож на WithDeadline, но позволяет указать таймаут вместо конкретного времени

**WithValue**(parent, key, value)
Этот контекст позволяет передавать данные между частями программы. Он используется для хранения информации, необходимой на протяжении выполнения всей операции, например, идентификатор запроса.
### Что нельзя передавать в контекст?
В контекст не следует передавать данные большого размера или чувствительные данные. Контексты предназначены для передачи сигналов (например, отмены) и небольших метаданных. Использование контекста для передачи значительных данных может привести к усложнению кода и даже проблемам с производительностью
### Отличие между context.Background() и context.TODO()

context.**Background**() используется как основной контекст, который служит начальной точкой для всех других контекстов. context.**TODO**() используется в тех местах, где пока не ясно, какой контекст должен быть использован. Это сигнал разработчику о необходимости уточнить контекст позже

### Что лучше не передавать в контекст со значением?

В контекст лучше не передавать значительные или изменяющиеся данные. Контекст предназначен для хранения небольших статических данных, таких как идентификаторы запросов, токены и т.д. Если в контексте хранить большие данные, это усложняет управление и снижает читаемость.

### Для чего используется **Context**?

Для передачи данных и управления сроками жизни между процессами, горутинами или запросами. Для сигналов об отмене операций

### Какие примитивы синхронизации есть в GO?

- [[Mutex]]
Он предотвращает одновременное выполнение нескольких горутин в критической секции
- [[RWmutex]]
- [[WaitGroup]]
Используется для синхронизации выполнения горутин, позволяя основной программе ожидать их завершения
- [[atomic]]
Для простых числовых операций без необходимости сложной блокировки
- Каналы ?
Передача данных между горутинами
- Context ?
Контроль времени жизни горутин (таймауты, отмена)

### Что такое race condition / гонка данных?
**Race condition** - состояние, когда несколько горутин пытаются изменить или прочитать из одной переменной. Так как любые операции над переменными не атомарные (выполняются не за одну операцию) может произойти так, что одна горутина УВЕЛИЧИТ переменную, но не успеет сохранить эти изменения, и в этот же момент другая горутина ПРОЧИТАЕТ старые данные, и опять УВЕЛИЧИТ на то же значение

### Что такое **deadlock**?

**Deadlock** (взаимная блокировка) — это состояние, при котором несколько горутин (или процессов) блокируют друг друга, ожидая освобождения ресурсов, которые уже заняты друг другом 
**Deadlock** возникает, когда каждая из горутин удерживает ресурс, необходимый другой, и никто из них не может продолжить выполнение


### Что такое семафор и воркерпул?

**Семафор**: ограничивает доступ к ресурсу, контролируя количество активных потоков (Ограничение параллелизма)
Он позволяет нескольким горутинам или потокам одновременно получить доступ к ограниченному количеству "разрешений"

Изначально у семафора есть заданное количество "разрешений" (например, 3).

<u>Для реализации семафора в Go можно использовать каналы</u>
```go
func main() {
    const maxWorkers = 3 // Максимальное количество разрешений
    sem := make(chan struct{}, maxWorkers) // Семафор
    var wg sync.WaitGroup

    tasks := []int{1, 2, 3, 4, 5} // Список задач

    for _, task := range tasks {
        wg.Add(1)
        go func(task int) {
            defer wg.Done()
            sem <- struct{}{} // Захватываем разрешение
            fmt.Printf("Выполняется задача %d\n", task)
            time.Sleep(2 * time.Second) // Симуляция работы
            fmt.Printf("Задача %d завершена\n", task)
            <-sem // Освобождаем разрешение
        }(task)
    }
    wg.Wait()
    fmt.Println("Все задачи завершены")
}
```
- Канал **sem** ограничивает число одновременно работающих горутин (до `maxWorkers`)
- Горутины блокируются, если канал заполнен

**Воркерпул**: пул горутин, распределяющий задачи для экономии ресурсов(Балансировка нагрузки)
#### Как работает Worker Pool

- Создаётся **пул горутин** ("воркеров"), которые ожидают задачи
- Задачи добавляются в общую очередь
- Воркер извлекает задачу из очереди, выполняет её, затем переходит к следующей
- Когда все задачи выполнены, воркеры завершают свою работу

```go
// Воркер, выполняющий задачу
func worker(id int, tasks <-chan int, wg *sync.WaitGroup) {
    defer wg.Done()
    for task := range tasks {
        fmt.Printf("Воркер %d: выполняет задачу %d\n", id, task)
        time.Sleep(1 * time.Second) // Симуляция работы
        fmt.Printf("Воркер %d: завершил задачу %d\n", id, task)
    }
}

func main() {
    const numWorkers = 3 // Количество воркеров
    tasks := make(chan int, 10) // Очередь задач
    var wg sync.WaitGroup

    // Запускаем воркеров
    for i := 1; i <= numWorkers; i++ {
        wg.Add(1)
        go worker(i, tasks, &wg)
    }

    // Добавляем задачи в очередь
    for i := 1; i <= 10; i++ {
        tasks <- i
    }

    close(tasks) // Закрываем канал задач, чтобы воркеры знали, что задачи закончились

    wg.Wait()
    fmt.Println("Все задачи выполнены")
}
```

### Что такое Graceful Shutdown?

Корректное завершение приложения с ожиданием завершения текущих операций
**В Go**: используют [[Context]] и sync.[[WaitGroup]]

#### Зачем нужен Graceful Shutdown

**Избежание потери данных**: Позволяет завершить выполнение текущих операций (например, обработка HTTP-запросов или транзакций в БД)

**Освобождение ресурсов:**: Закрытие открытых файлов, соединений с базами данных, сокетов и других ресурсов.

#### Как работает Graceful Shutdown
1. Приложение получает [[системные сигналы]](**например**, SIGTERM или SIGINT) и запускает процедуру завершения
2. **Завершение текущих задач**: Сервер перестаёт принимать новые запросы, но завершает обработку уже начатых
3. **Освобождение ресурсов**: Закрытие файлов, соединений с базами данных, остановка горутин и т.д

### В каком порядке вызывается **defer** ?

[[Defer]] добавляет переданную после него функцию в стек, который работает по принципу LIFO (Last In First Out), поэтому функции вызовуются в обратном порядке

### Для чего используется atomic?
[[atomic]] - предоставляет набор атомарных функций, реализованных на аппаратном уровне. Это позволяет избегать гонки данных без блокировок. Вместе с этим, с помощью `atomic` в отличие от [[Mutex]] можно делать только простые вещи, к примеру инкрементировать различные счетчики
