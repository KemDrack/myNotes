

### Чем отличается пустой интерфейс от пустой структуры?

Пустой интерфейс может использоваться когда тип данных заранее не известен, в качестве полиморфизма([[Полиморфизм]]) и он может принимать значения любого типа

Пустая структура, это структура которая не содержит никаких полей, мы можем использовать ее для передачи сигналов в каналах, когда важен сам факт отправки сообщения, а не его содержимое

### Что содержится внутри интерфейса?

- Тип значения, которое реализует интерфейс
- Само значение, которое хранится в интерфейсе

Эта пара (`Type` и `Value`) позволяет интерфейсу работать с данными любого типа

### Какие ключи могут быть у мапы?

Ключами мапы могут быть **любые** значения, которые мы можем **сравнивать**через == или !=

**Простые типы**
`int`, `uint`, `float64`, `bool`

**Строки** (`string`), **Символы**: `rune`

**Указатели**
Указатели (`*T`) можно использовать, так как они сравниваются по адресам.

**Структуры**
Можно использовать, если все поля структуры содержат сравнимые типы

#### Типы, которые нельзя использовать в качестве ключей:

**Слайсы**
- Слайсы нельзя сравнивать напрямую, так как они содержат указатели на данные.
- 
**Мапы (`map[T]U`):**
- Мапы нельзя сравнивать, кроме сравнения с `nil`.

**Функции**
Функции тоже нельзя сравнивать, кроме как с `nil`.

**Каналы**  

**Интерфейсы с динамическим типом**

<u>Если вам нужно использовать слайс, мапу или функцию в качестве ключа, вы можете:</u>
1. **Преобразовать ключ в строку (или другой сравнимый тип):**
    - Например, для слайса:
```go
func sliceToString(slice []int) string {
    return fmt.Sprintf("%v", slice)
}

m := make(map[string]int)
m[sliceToString([]int{1, 2, 3})] = 42
```
2. Вместо слайса или мапы можно использовать структуру, в которой поля сравнимы.
```go
type Key struct {
    Data string
}

m := make(map[Key]string)
m[Key{Data: "ключ"}] = "значение"
```

### Как посчитать количество символов в строке?

**len(str)** считает количество байтов, поэтому мы можем получить неверный ответ
Если строка содержит символы ==Unicode== (многобайтовые символы), длина в байтах может отличаться от количества символов


Чтобы посчитать количество символов, мы должны конвертировать строку в срез **[[Rune]]** и смотреть len от рун:
```go
package main

import "fmt"

func main() {
    str := "Привет"
    fmt.Println(len([]rune(str))) // Вывод: 6 (количество символов в строке)
}
```

или же использовать метод utf8.*RuneCountInString*
<font color="#9bbb59">Этот способ оптимальнее, чем использование []rune, так как он не создаёт новый массив.</font>

### Как преобразовать строку в int и наоброот?
Использовать **strconv.Atoi** или **strconv.ParseInt**
```go
package main

import (
    "fmt"
    "strconv"
)

func main() {
    str := "42"                  // Строка
    number, err := strconv.Atoi(str) // Преобразование строки в int
    if err != nil {
        fmt.Println("Ошибка:", err)
        return
    }
    fmt.Println("Число:", number) // Вывод: 42
}
```

**Преобразование из int -> string** с помощью strconv.Itoa()
```go
package main

import (
    "fmt"
    "strconv"
)

func main() {
    number := 42                   // Число
    str := strconv.Itoa(number)    // Преобразование int в строку
    fmt.Println("Строка:", str)    // Вывод: "42"
}
```

Если вам **нужно преобразовать строку в числа других типов**, например `float64` или `int64`, используются другие функции из пакета `strconv`.

```go
int64
number, err := strconv.ParseInt("42", 10, 64) // Строка "42", система счисления 10, размер 64 бита
if err == nil {
    fmt.Println("int64:", number)
}
-------------------
float64
floatNum, err := strconv.ParseFloat("3.14", 64)
if err == nil {
    fmt.Println("float64:", floatNum) // Вывод: 3.14
}
-------------------
Число в строку
str := strconv.FormatFloat(3.14, 'f', 2, 64) // 2 знака после запятой
fmt.Println("Строка:", str) // Вывод: "3.14"
```

### Как работает append для слайса?

- `append` добавляет элементы в слайс
- Если в слайсе достаточно свободного места (ёмкость позволяет), новые элементы добавляются без создания нового массива.
- Если места недостаточно, создаётся новый массив с увеличенной ёмкостью, и все элементы копируются в него.

> [!NOTE]
> > Append расширяет слайс за пределы его len, возвращая при этом новый слайс. Если длинна нового слайса больше чем **cap,** то новый слайс также будет указывать на новый низлежайший массив

```go
a := []int{1, 2}
b := a
a = append(a, 3)

fmt.Println(a) // [1 2 3]
fmt.Println(b) // [1 2]
```

### Как реализованна **map** в go?

[[Мапы]] это структура которая хранит в себе данные в формате **ключ:значение. Мапа** ссылается на **ведра,** в каждом из которых содержится **8 пар ключ:значение** и **ссылка на следующее ведро**

### Можно ли взять адрес элемента мапы?

Нет, нельзя. Мапа представляет из себя хэш таблицу, и при проведении различных операций над мапой([[Когда происходит перехеширование]]), элементы могут быть перемещены в другие ведра

### Что такое эвакуация данных (В контексте мапы

Это процесс переопределения данных в мапе,когда мапа растет и ей требуется больше места, чтобы поддерживать эффективную работу хэш-таблицы. При перераспределении мапы старые элементы "эвакуируются" из старой хэш-таблицы и вставляются в новую, которая имеет больший размер. Это одна из причин, почему адрес элемента мапы не может быть стабильно зафиксирован — местоположение элемента может измениться в результате процесса эвакуации

### Какие типы данных мы **НЕ** можем сравнивать через == или != (соответственно не можем хранить в мапе)

**Слайсы  
Мапы  
Функции  
Каналы**  
Интерфейсы с динамическим типом

### Какие численные типы есть в GO?

- `int`: размер зависит от архитектуры (обычно 32 или 64 бита).
Сколько места в памяти занимают int32 и int64?
**4** байта и **8** соответственно (нужно делить на 8)

int  
uint  
float  
complex  
rune (синоним `int32`)
byte (синоним `uint8`)

### Что будет если разделить int и float на 0?

при делении **int** на 0 мы получим **ошибку**, деление на **float** получаем **бесконечность** ище можем получить минус бесконечность или неопределенное значение

### Что представляют из себя строки в GO?

**Строки**  это **неизменяемый** **массив байт**

### Что такое слайс и как он отличается от массива?

**Массив** это выделенная область в памяти **неизменяемой длинны**, а **слайс**это структура которая включает в себя **указатель на низлежайший массив**, **len** и **capacity**


