
В отличие от Rest у gRPC все делается через **POST**

**HTTP 1.1 vs gPRC** (HTTP 2)
- На каждое HTTP соединение создается новое TCP соединение (Безусловно можно серверу сказать, чтобы он не закрывал соединение с помощью keep-alive заголовка, но по дефолту он будет расточительно расходовать ресурсы)
- **Head of blocking** (Например если мы с сервера заказали 3 файлика: JS,CSS,HTML. К примеру JS самый жирный и получается такая ситуация, что полез JS, мы же передаем через пакеты, чтобы файл по сети пролез и клиент на своей стороне, если он начал принимать файлы JS жирного, то он будет только их принимать до самого конца, он не может их комбинировать с CSS) 
- Не сжимает заголовки
- Нет server Push (Сокеты тяжело настраивать)
![[{B22415EE-9F75-4DDE-9518-07A2104CB436}.png]]
 

Protobuf
- **Меньший размер** (запаковка идет в бинарном виде и позволяет произвести сжатие(Protobuf не передает имена полей, он передает только номера полей))
- **Типизация** (Позволяет более жестко зафиксировать контракт)
- **Схема данных** (Контракт описали, сказали вот такие поля)
- **Разные языки** (Написав Protobuf одиноразово можем сгенерировать код под различные языки)

В Protobuf все поля по дефолту оптиональные, можно что то не указать в контракте, когда она в гошку перейдет, но мы помнил что у гошки есть zeroValue. Мы какой-нибудь параметр int передаем и мы не указали этот параметр, он по дефолту будет 0, а может быть мы его передали и сами задали 0, **для этого придуманы nullab-ельные типы данных**

Типы данных: 
- **float**, **sint32/64**(int который может быть **полож** и **отр**, но его внутренняя струкутура такова, что он оптимизирован под отризательные числа), **fixed32/64**(оптимизирован под здоровенные числа), **bool**, **byte**, **string**
- **nullable type** - будут null, если ничего не передали.

