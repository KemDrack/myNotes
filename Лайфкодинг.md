### 1 задача
```go
func main() {
	v := []int{3, 4, 1, 2, 5}
	ap(v)
	sr(v)
	fmt.Println(v)
}
func ap(arr []int) {
	arr = append(arr, 10)
}
func sr(arr []int) {
	sort.Ints(arr)
}
```

- Функции, которые изменяют срез (например, `append`), должны возвращать новый срез, если требуется изменить исходный срез.
```go
func main() {
	v := []int{3, 4, 1, 2, 5}
	v = ap(v) // Присваиваем результат функции ap
	sr(v)
	fmt.Println(v)
}
func ap(arr []int) []int {
	arr = append(arr, 10)
	return arr // Возвращаем новый срез
}
func sr(arr []int) {
	sort.Ints(arr)
}
```

**можно использовать указатель на срез**
```go
func main() {  
    v := []int{3, 4, 1, 2, 5}  
    ap(&v)  
    sr(v)  
    fmt.Println(v)  
}  
func ap(arr *[]int) {  
    *arr = append(*arr, 10)  
  
}  
func sr(arr []int) {  
    sort.Ints(arr)  
}
```
Функция `ap` не изменяет исходный срез `v`, потому что:

1. `v` передаётся по **значению** (копируется структура среза).
2. `append` создаёт новый массив, если ёмкость недостаточна.
3. Копия структуры среза внутри функции указывает на новый массив, но оригинальная структура среза остаётся неизменной.

### Задача 2
```go
var foo []int
var bar []int

foo = append(foo, 1)
foo = append(foo, 2)
foo = append(foo, 3)
bar = append(foo, 4)
foo = append(foo, 5)

fmt.Println(foo, bar)
```
Результат вывода:
[1 2 3 5] [1 2 3 5]

Это происходит, потому что bar ссылается на тот же массив, что и foo

foo = append(foo, 3) // [1, 2, 3]
bar = append(foo, 4) // Ссылается на foo, [1, 2, 3, 4]
foo = append(foo, 5) // не в курсе изменений в bar. [1, 2, 3, 5]

Так как bar ссылается на foo, изменения в нем будут переписаны
при изменении foo

если мы удалим строчку foo = append(foo, 5), то изменения в bar останутся

### Задача 3.

```go
func main() {
  c := []string{"A", "B", "D", "E"}
  b := c[1:2]
  b = append(b, "TT")
  fmt.Println(c)
  fmt.Println(b)
}
```

Результат вывода:
[A B TT E]
[B TT]

Схожее поведение с задачей номер 2.
При создании слайса от слайса, b указывает на тот же массив, что и c
b := c[1:2] // от 1 элемента до 2, не включая 2
При добавлении в b элемента TT переписывается D, потому что
b имеет доступ к 1-2 элементам массива

### Задача 4.
```go
func main() {
	mutate := func(a []int) {
		a[0] = 0
		a = append(a, 1)
		fmt.Println(a)
	}
	a := []int{1, 2, 3, 4}
	mutate(a)
	fmt.Println(a)
}
```

Результат вывода:
[0 2 3 4 1] // Print из mutate, создался новый массив и 1 добавилась
[0 2 3 4] // Print из main

a[0] = 0 // меняем элемент оригинального массива
a = append(a, 1) // создаем новый массив, поэтому оригинальный не меняется

### Задача 5.
```go
func foo(arr []int) {
    arr = append(arr, 9, 9)
}

func main() {
    src := []int{1, 2, 3, 4, 5}
    arr := src[:3]

    foo(arr)

    fmt.Println(src)
    fmt.Println(arr)
}
```
Результат вывода:
[1 2 3 9 9] 
[1 2 3]

arr = append(arr, 9, 9) // изменяет базовый массив src из-за достаточной ёмкости
fmt.Println(arr) // выводит только первые 3 элемента, длина arr не изменилась

### Задача 6
```go
// Вариант 1
func mod(a []int) {
  for i := range a {
    a[i] = 5
  }
  fmt.Println(a)
}

func main() {
  sl := []int{1, 2, 3, 5}
  mod(sl)
  fmt.Println(sl)
}
```
Результат вывода:
[5 5 5 5]
[5 5 5 5]

В функции mod мы меняем in place элементы оригинального массива
"in place" означает, что изменения применяются к оригинальному массиву напрямую, а не создаётся его новая версия или копия.

### Задача 7. Что будет содержать s после инициализации? Что произойдет в println для слайса и мапы?
```go
func a(s []int) {
    s = append(s, 37)
}

func b(m map[int]int) {
    m[3] = 33
}

func main() {
    s := make([]int, 3, 8)
    m := make(map[int]int, 8)

    // add to slice
    a(s)
    println(s[3]) //?

    // add to map
    b(m)
    println(m[3]) //?
}
```
1. **Что будет содержать `s` после инициализации?**
    - После `s := make([]int, 3, 8)`:
        - `s` содержит `[0, 0, 0]`.
        - `len(s) = 3`, `cap(s) = 8`.
2. **Что произойдёт при `println(s[3])`?**
    - **Паника (`runtime error: index out of range`)**:
        - Функция `a` не изменяет исходный слайс `s` (передача по значению), а создаёт новую копию указателя на массив, увеличивая её длину.
        - Индекс `3` выходит за пределы исходного слайса, который имеет длину `3`.
3. **Что будет содержать `m` после вызова `b(m)`?**
    - `m[3] = 33`, потому что мапы передаются по ссылке.
4. **Что произойдёт при `println(m[3])`?**
    - Выведет `33`.

### Задача 8. Подробно рассказать что происходит
```go
func main() {
    a := []int{1,2}
    a = append(a, 3)
    b := append(a, 4)
    c := append(a, 5)

    fmt.Println(b)
    fmt.Println(c)
}
```
1. **`a := []int{1, 2}`**:
    - Создаётся слайс `a` с длиной 2 и ёмкостью 2.
2. **`a = append(a, 3)`**:
    - Так как ёмкость исходного массива недостаточна (только 2), создаётся **новый массив** с удвоенной ёмкостью (4).
    - `a` теперь указывает на массив `[1, 2, 3]` с длиной 3 и ёмкостью 4.
3. **`b := append(a, 4)`**:
    - Элемент `4` добавляется в массив, на который указывает `a`. Теперь массив становится `[1, 2, 3, 4]`.
    - `b` указывает на тот же массив, что и `a`.
4. **`c := append(a, 5)`**:
    - Элемент `5` добавляется в массив, на который указывает `a`. Теперь массив становится `[1, 2, 3, 5]`.
    - Однако **оба** слайса (`b` и `c`) указывают на один и тот же массив, потому что:
        - Ёмкость исходного массива (4) не исчерпана.
        - `append` не создаёт новый массив, если хватает текущей ёмкости.
5. **`fmt.Println(b)` и `fmt.Println(c)`**:
    - Так как `b` и `c` ссылаются на один и тот же массив, выводит `[1 2 3 5]` для обоих.
### Интересная задача:
```go
func main() {
    s := []int{1, 2, 3}
    modify(s)
    fmt.Println(s)
}
func modify(s []int) {
    for i, n := range s {
        s[i] = n * 2
        if i%2 == 0 {
            s = append(s, i*2)
        }
    }
    fmt.Println("in func:", s)
}
```
вывод будет 
in func: [2 4 6 0 4]
[2 2 3]

### Задача 9
```go
func main() {
    v := 5
    p := &v
    
    fmt.Println(*p)
    
    changePointer(p)
    fmt.Println(*p)
}
func changePointer(p *int) {
     := 3
    p = &v
}
```