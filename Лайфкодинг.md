

### Задача 1.

```go
func main() {
	v := []int{3, 4, 1, 2, 5}
	ap(v)
	sr(v)
	fmt.Println(v)
}

func ap(arr []int) {
	arr = append(arr, 10)
}

func sr(arr []int) {
	sort.Ints(arr)
}
```

- **Ответ**
    
    ```go
    *Результат вывода:*
    [1 2 3 4 5]
    
    Так происходит, потому что мы передаем **копию слайса, содержащую:**
    len, cap и указатель на низлежайший массив.
    
    вызывая append у нас создается новый слайс
    но так как мы его не возвращаем, оригинальный слайс не меняется
    
    sort тоже работает с копией, но с копией ***указателя***
    Именно поэтому оригинальный массив изменится
    ```
    

### Задача 2.

```go
var foo []int
var bar []int

foo = append(foo, 1)
foo = append(foo, 2)
foo = append(foo, 3)
bar = append(foo, 4)
foo = append(foo, 5)

fmt.Println(foo, bar)
```

- **Ответ**
    
    ```go
    Результат вывода:
    [1 2 3 5] [1 2 3 5]
    
    Это происходит, потому что bar ссылается на тот же массив, что и foo
    
    foo = append(foo, 3) // [1, 2, 3]
    bar = append(foo, 4) // Ссылается на foo, [1, 2, 3, 4]
    foo = append(foo, 5) // не в курсе изменений в bar. [1, 2, 3, 5]
    
    Так как bar ссылается на foo, изменения в нем будут переписаны
    при изменении foo
    
    если мы удалим строчку foo = append(foo, 5), то изменения в bar останутся
    ```

### Задача 3.

```go
package main

import "fmt"

func main() {
  c := []string{"A", "B", "D", "E"}
  b := c[1:2]
  b = append(b, "TT")
  fmt.Println(c)
  fmt.Println(b)
}
```

- **Ответ**
    
    ```go
    Результат вывода:
    [A B TT E]
    [B TT]
    
    Схожее поведение с задачей номер 2.
    При создании слайса от слайса, ***b*** указывает на тот же массив, что и ***c***
    b := c[1:2] // от 1 элемента до 2, не включая 2
    При добавлении в ***b*** элемента *TT* переписывается *D*, потому что
    ***b*** имеет доступ к 1-2 элементам массива
    ```
    

### Задача 4.

```go
func main() {
	mutate := func(a []int) {
		a[0] = 0
		a = append(a, 1)
		fmt.Println(a)
	}
	a := []int{1, 2, 3, 4}
	mutate(a)
	fmt.Println(a)
}
```

- **Ответ**
    
    ```go
    Результат вывода:
    [0 2 3 4 1] // Print из ***mutate***, создался новый массив и 1 добавилась
    [0 2 3 4] // Print из ***main***
    
    a[0] = 0 // меняем элемент оригинального массива
    a = append(a, 1) // создаем новый массив, поэтому оригинальный не меняется
    ```

### Задача 5.

```go
func foo(arr []int) {
    arr = append(arr, 9, 9)
}

func main() {
    src := []int{1, 2, 3, 4, 5}
    arr := src[:3]

    foo(arr)

    fmt.Println(src)
    fmt.Println(arr)
}
```

- **Ответ**
    
    ```go
    Результат вывода:
    [1 2 3 9 9] 
    [1 2 3]
    
    arr = append(arr, 9, 9) // изменяет базовый массив src из-за достаточной ёмкости
    fmt.Println(arr) // выводит только первые 3 элемента, длина arr не изменилась
    ```
    

### Задача 6.

```go
// Вариант 1
func mod(a []int) {
  for i := range a {
    a[i] = 5
  }
  fmt.Println(a)
}

func main() {
  sl := []int{1, 2, 3, 5}
  mod(sl)
  fmt.Println(sl)
}
```

- **Ответ**
    
    ```go
    Результат вывода:
    [5 5 5 5]
    [5 5 5 5]
    
    В функции mod мы меняем in place элементы оригинального массива

// Вариант 2
func mod(a []int) {
  for i := range a {
    a[i] = 5
  }
  fmt.Println(a)
}

func main() {
  sl := make([]int, 4, 8)
  sl[0] = 1
  sl[1] = 2
  sl[2] = 3
  sl[3] = 5
  mod(sl)
  fmt.Println(sl)
}
    ```


### Задача 7. Что будет содержать s после инициализации? Что произойдет в println для слайса и мапы?

```go
func a(s []int) {
    s = append(s, 37)
}

func b(m map[int]int) {
    m[3] = 33
}

func main() {
    s := make([]int, 3, 8)
    m := make(map[int]int, 8)

    // add to slice
    a(s)
    println(s[3]) //?

    // add to map
    b(m)
    println(m[3]) //?
}
```

- **Ответ**
    1. **Что будет содержать `s` после инициализации?**
        - После `s := make([]int, 3, 8)`:
            - `s` содержит `[0, 0, 0]`.
            - `len(s) = 3`, `cap(s) = 8`.
    2. **Что произойдёт при `println(s[3])`?**
        - **Паника (`runtime error: index out of range`)**:
            - Функция `a` не изменяет исходный слайс `s` (передача по значению), а создаёт новую копию указателя на массив, увеличивая её длину.
            - Индекс `3` выходит за пределы исходного слайса, который имеет длину `3`.
    3. **Что будет содержать `m` после вызова `b(m)`?**
        - `m[3] = 33`, потому что мапы передаются по ссылке.
    4. **Что произойдёт при `println(m[3])`?**
        - Выведет `33`.

### Задача 8. Подробно рассказать что происходит

```go
package main

import "fmt"

func main() {
    a := []int{1,2}
    a = append(a, 3)
    b := append(a, 4)
    c := append(a, 5)

    fmt.Println(b)
    fmt.Println(c)
}
```

- **Ответ**
    1. **`a := []int{1, 2}`**:
        - Создаётся слайс `a` с длиной 2 и ёмкостью 2.
    2. **`a = append(a, 3)`**:
        - Так как ёмкость исходного массива недостаточна (только 2), создаётся **новый массив** с удвоенной ёмкостью (4).
        - `a` теперь указывает на массив `[1, 2, 3]` с длиной 3 и ёмкостью 4.
    3. **`b := append(a, 4)`**:
        - Элемент `4` добавляется в массив, на который указывает `a`. Теперь массив становится `[1, 2, 3, 4]`.
        - `b` указывает на тот же массив, что и `a`.
    4. **`c := append(a, 5)`**:
        - Элемент `5` добавляется в массив, на который указывает `a`. Теперь массив становится `[1, 2, 3, 5]`.
        - Однако **оба** слайса (`b` и `c`) указывают на один и тот же массив, потому что:
            - Ёмкость исходного массива (4) не исчерпана.
            - `append` не создаёт новый массив, если хватает текущей ёмкости.
    5. **`fmt.Println(b)` и `fmt.Println(c)`**:
        - Так как `b` и `c` ссылаются на один и тот же массив, выводит `[1 2 3 5]` для обоих.

