Master остаётся единственным источником правды для записей, а Slave — для распределения нагрузки на чтение

#### **Этап 1: Изменения на Master**
Когда данные изменяются на сервере **Master** (вставка, удаление, обновление), эти изменения записываются в **журнал транзакций** (например, Write-Ahead Log, [[WAL в PostgreSQL]] или бинарный лог в MySQL)

#### **Этап 2: Передача изменений**

**Master отправляет лог на Slave:**
- Master регулярно или непрерывно передаёт обновления из своего журнала транзакций на серверы Slave
- Это делается через сетевое соединение
**Slave читает журнал:**
- Slave получает логи изменений и применяет их локально

#### **Этап 3: Применение данных на Slave**
Slave обновляет свою копию базы данных, основываясь на инструкциях, полученных от Master (например, добавляет или удаляет строки).
### Как Slave обрабатывает запросы клиента?

Обычно это SELECT-запросы, так как Slave обрабатывает запросы на чтение
```sql
SELECT * FROM orders WHERE status = 'completed';
```
Slave отвечает на запросы, используя локальную копию данных, полученную от Master


<font color="#9bbb59">Маршрутизация запросов</font>
Чтобы клиенты отправляли запросы именно на Slave:

1. Используются **балансировщики нагрузки** ([[load balancer]]), которые направляют запросы на нужный сервер
2. Приложение может быть настроено так, чтобы отправлять:
- Все записи на Master
- Все чтения на Slave

